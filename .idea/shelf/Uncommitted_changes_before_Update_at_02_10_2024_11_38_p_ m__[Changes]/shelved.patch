Index: dev/risas/protection/ProtectedLaunch.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package dev.risas.protection;\r\n\r\nimport dev.risas.Rise;\r\nimport dev.risas.command.Command;\r\nimport dev.risas.command.CommandManager;\r\nimport dev.risas.command.impl.PlayerHacks;\r\nimport dev.risas.command.impl.*;\r\nimport dev.risas.creative.RiseTab;\r\nimport dev.risas.module.Module;\r\nimport dev.risas.module.impl.combat.*;\r\nimport dev.risas.module.impl.ghost.*;\r\nimport dev.risas.module.impl.movement.*;\r\nimport dev.risas.module.impl.other.Sniper;\r\nimport dev.risas.module.impl.other.Spammer;\r\nimport dev.risas.module.impl.other.*;\r\nimport dev.risas.module.impl.player.*;\r\nimport dev.risas.module.impl.render.*;\r\nimport dev.risas.module.impl.render.particles.Particles;\r\nimport dev.risas.module.impl.render.targethud.TargetHud;\r\nimport dev.risas.module.manager.ModuleManager;\r\nimport dev.risas.notifications.NotificationManager;\r\nimport dev.risas.script.ScriptManager;\r\nimport dev.risas.ui.altmanager2.alt.GuiAltLogin;\r\nimport dev.risas.ui.auth.AuthGUI;\r\nimport dev.risas.ui.clickgui.impl.ClickGUI;\r\nimport dev.risas.ui.clickgui.impl.strikeless.StrikeGUI;\r\nimport dev.risas.ui.guitheme.GuiTheme;\r\nimport dev.risas.ui.mainmenu.MainMenu;\r\nimport dev.risas.ui.version.VersionGui;\r\nimport dev.risas.util.misc.FileUtil;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.gui.GuiMultiplayer;\r\nimport net.minecraft.client.main.Main;\r\nimport store.intent.api.account.IntentAccount;\r\nimport store.intent.intentguard.annotation.Bootstrap;\r\nimport store.intent.intentguard.annotation.Native;\r\n\r\nimport java.io.File;\r\n\r\n@Native\r\npublic class ProtectedLaunch {\r\n\r\n    @Native\r\n    @Bootstrap\r\n    public static void start() {\r\n        if (Main.apiKey != null && !Main.apiKey.isEmpty())\r\n            Rise.intentAccount = new IntentAccount();\r\n\r\n        if (Rise.intentAccount == null) Rise.intentAccount = new IntentAccount();\r\n\r\n        final Rise instance = Rise.INSTANCE;\r\n        //ircClient = new IRCClient();\r\n        try {\r\n            (instance.moduleManager = new ModuleManager()).moduleList = new Module[]{\r\n                    // IMPORTANT RENDER\r\n                    new Interface(),\r\n                    new TabGui(),\r\n\r\n                    // COMBAT\r\n                    new AutoGap(),\r\n                    new AutoHead(),\r\n                    new Aura(),\r\n                    new FastBow(),\r\n                    new TPAura(),\r\n                    new BackTrack(),\r\n                    new Velocity(),\r\n                    new TargetStrafe(),\r\n                    new FastBow(),\r\n                    new AutoSoup(),\r\n                    new FightBot(),\r\n                    new AntiBot(),\r\n                    new WTap(),\r\n                    new Criticals(),\r\n                    new ComboOneHit(),\r\n                    new Regen(),\r\n                    new AttackCrash(),\r\n\r\n                    // PLAYER\r\n                    new Derp(),\r\n                    new ChestAura(),\r\n                    new Stealer(),\r\n                    new AutoTool(),\r\n                    new FastPlace(),\r\n                    new FastEat(),\r\n                    new NoVoid(),\r\n                    new NoFall(),\r\n                    new Scaffold(),\r\n                    new FastBreak(),\r\n                    new Manager(),\r\n                    new Infinite(),\r\n\r\n                    // MOVEMENT\r\n                    new Sprint(),\r\n                    new Sneak(),\r\n                    new ResetVL(),\r\n                    new Fly(),\r\n                    new Speed(),\r\n                    new No003(),\r\n                    new Strafe(),\r\n                    new Jesus(),\r\n                    new NoSlow(),\r\n                    new HighJump(),\r\n                    new LongJump(),\r\n                    new InvMove(),\r\n                    new Step(),\r\n                    new Phase(),\r\n                    new Blink(),\r\n                    new Spider(),\r\n                    new ClickTP(),\r\n                    new BedWalker(),\r\n                    new BowFly(),\r\n                    new Clipper(),\r\n                    new Terrain(),\r\n                    new SafeWalk(),\r\n                    new NoBob(),\r\n\r\n                    // GHOST\r\n                    new AimAssist(),\r\n                    new Reach(),\r\n                    new AutoClicker(),\r\n                    new LegitScaffold(),\r\n                    new KeepSprint(),\r\n                    new Hitboxes(),\r\n                    new Eagle(),\r\n                    new NoClickDelay(),\r\n                    new Keystrokes(),\r\n                    new Freelook(),\r\n\r\n                    // OTHER\r\n                    new AutoHypixel(),\r\n                    new Disabler(),\r\n                    new Plugins(),\r\n                    new AutoAuthme(),\r\n                    new NoRot(),\r\n                    new Insults(),\r\n                    new ChatBypass(),\r\n                    new Breaker(),\r\n                    new AutoGroomer(),\r\n                    new Nuker(),\r\n                    new Timer(),\r\n                    new Spammer(),\r\n                    new Crasher(),\r\n                    new PingSpoof(),\r\n                    new NoGuiClose(),\r\n                    new AntiSuffocation(),\r\n                    new dev.risas.module.impl.other.PlayerHacks(),\r\n                    new AntiCheat(),\r\n                    //new StaffAlert(),\r\n                    new Sniper(),\r\n                    new ClientSpoofer(),\r\n                    new AutoBuild(),\r\n                    new Denicker(),\r\n                    new ViaMCPFix(),\r\n                    new Test(),\r\n\r\n                    // RENDER\r\n                    new ShaderESP(),\r\n                    new PopOutAnimation(),\r\n                    new ChinaHat(),\r\n                    new Hitmarks(),\r\n                    new SimsESP(),\r\n                    new ClickGui(),\r\n                    new Nametags(),\r\n                    new Chams(),\r\n                    new BrightPlayers(),\r\n                    new ESP(),\r\n                    new Animations(),\r\n                    new Ambiance(),\r\n                    new AttackEffects(),\r\n                    new TargetHud(),\r\n                    new DamageColor(),\r\n                    new TwoDESP(),\r\n                    new Enchant(),\r\n                    new DeathEffects(),\r\n                    new Zoot(),\r\n                    new Fullbright(),\r\n                    new NoWeather(),\r\n                    new Giants(),\r\n                    new Freecam(),\r\n                    new Tracers(),\r\n                    new NameProtect(),\r\n                    new Streamer(),\r\n                    new Scoreboard(),\r\n                    new Breadcrumbs(),\r\n                    new Radar(),\r\n                    new Blur(),\r\n                    new ChestESP(),\r\n                    new NoHurtCam(),\r\n                    new CameraClip(),\r\n                    new ItemPhysics(),\r\n                    new MotionGraph(),\r\n                    new NoAchievements(),\r\n                    new ImageESP(),\r\n                    new Health(),\r\n                    new XRay(),\r\n                    new Particles(),\r\n\r\n                    //SPECIAL ORDER (These modules events must be called in a specific order)\r\n                    new AutoPot(),\r\n                    new SSMode()\r\n            };\r\n\r\n            instance.notificationManager = new NotificationManager();\r\n\r\n            instance.cmdManager = new CommandManager();\r\n\r\n            CommandManager.COMMANDS = new Command[]{\r\n                    new Bind(),\r\n                    new Toggle(),\r\n                    new Config(),\r\n                    new Say(),\r\n                    new Friend(),\r\n                    new Crash(),\r\n                    new Target(),\r\n                    new ClientName(),\r\n                    new VClip(),\r\n                    new HClip(),\r\n                    new Panic(),\r\n                    new dev.risas.command.impl.Sniper(),\r\n                    new dev.risas.command.impl.Spammer(),\r\n                    new SetArea(),\r\n                    new PlayerHacks(),\r\n                    new Tp(),\r\n                    new Name(),\r\n                    new Help(),\r\n                    new Denick(),\r\n                    new Findnick(),\r\n                    new Respawn()\r\n            };\r\n        } catch (final Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        try {\r\n            instance.clickGUI = new ClickGUI();\r\n            instance.guiMainMenu = new MainMenu();\r\n            instance.guiMultiplayer = new GuiMultiplayer(instance.guiMainMenu);\r\n            instance.strikeGUI = new StrikeGUI();\r\n            instance.altGUI = new GuiAltLogin();\r\n            instance.altManagerGUI = new GuiAltLogin();\r\n            instance.guiTheme = new GuiTheme();\r\n            instance.antiCheat = new dev.risas.anticheat.AntiCheat();\r\n            instance.scriptManager = new ScriptManager();\r\n            instance.creativeTab = new RiseTab();\r\n        } catch (final Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        final Minecraft mc = Minecraft.getMinecraft();\r\n\r\n        // Compatibility\r\n        mc.gameSettings.guiScale = 2;\r\n        mc.gameSettings.ofFastRender = false;\r\n\r\n        // Performance settings\r\n        mc.gameSettings.ofSmartAnimations = true;\r\n        mc.gameSettings.ofSmoothFps = false;\r\n\r\n        try {\r\n            // Creating Rise folder\r\n            if (!FileUtil.riseDirectoryExists()) {\r\n                instance.firstBoot = true;\r\n                FileUtil.createRiseDirectory();\r\n            }\r\n\r\n            if (!FileUtil.exists(\"Config\" + File.separator)) {\r\n                FileUtil.createDirectory(\"Config\" + File.separator);\r\n            }\r\n\r\n            if (!FileUtil.exists(\"Script\" + File.separator)) {\r\n                FileUtil.createDirectory(\"Script\" + File.separator);\r\n            }\r\n        } catch (final Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        try {\r\n            instance.loadClient();\r\n        } catch (final Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        AuthGUI.authed = true;\r\n        mc.displayGuiScreen(instance.getGuiMainMenu());\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/dev/risas/protection/ProtectedLaunch.java b/dev/risas/protection/ProtectedLaunch.java
--- a/dev/risas/protection/ProtectedLaunch.java	(revision 12f741f73fd2ba762ae96403a891020f2d06a691)
+++ b/dev/risas/protection/ProtectedLaunch.java	(date 1727749769947)
@@ -26,7 +26,6 @@
 import dev.risas.ui.clickgui.impl.strikeless.StrikeGUI;
 import dev.risas.ui.guitheme.GuiTheme;
 import dev.risas.ui.mainmenu.MainMenu;
-import dev.risas.ui.version.VersionGui;
 import dev.risas.util.misc.FileUtil;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.GuiMultiplayer;
@@ -129,6 +128,7 @@
                     // OTHER
                     new AutoHypixel(),
                     new Disabler(),
+                    new DisablerOld(),
                     new Plugins(),
                     new AutoAuthme(),
                     new NoRot(),
Index: dev/risas/module/impl/movement/Speed.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n Copyright Alan Wood 2021\r\n None of this code to be reused without my written permission\r\n Intellectual Rights owned by Alan Wood\r\n */\r\npackage dev.risas.module.impl.movement;\r\n\r\nimport dev.risas.Rise;\r\nimport dev.risas.event.impl.motion.PreMotionEvent;\r\nimport dev.risas.event.impl.other.*;\r\nimport dev.risas.event.impl.packet.PacketReceiveEvent;\r\nimport dev.risas.event.impl.packet.PacketSendEvent;\r\nimport dev.risas.event.impl.render.Render2DEvent;\r\nimport dev.risas.font.CustomFont;\r\nimport dev.risas.module.Module;\r\nimport dev.risas.module.api.ModuleInfo;\r\nimport dev.risas.module.enums.Category;\r\nimport dev.risas.module.impl.combat.Aura;\r\nimport dev.risas.module.impl.player.Scaffold;\r\nimport dev.risas.setting.impl.BooleanSetting;\r\nimport dev.risas.setting.impl.ModeSetting;\r\nimport dev.risas.setting.impl.NumberSetting;\r\nimport dev.risas.util.math.TimeUtil;\r\nimport dev.risas.util.player.MoveUtil;\r\nimport dev.risas.util.player.PacketUtil;\r\nimport dev.risas.util.player.PlayerUtil;\r\nimport net.minecraft.block.*;\r\nimport net.minecraft.client.gui.ScaledResolution;\r\nimport net.minecraft.client.settings.KeyBinding;\r\nimport net.minecraft.entity.player.EntityPlayer;\r\nimport net.minecraft.item.Item;\r\nimport net.minecraft.item.ItemStack;\r\nimport net.minecraft.network.Packet;\r\nimport net.minecraft.network.login.server.S00PacketDisconnect;\r\nimport net.minecraft.network.play.client.*;\r\nimport net.minecraft.network.play.server.S08PacketPlayerPosLook;\r\nimport net.minecraft.potion.Potion;\r\nimport net.minecraft.util.AxisAlignedBB;\r\nimport net.minecraft.util.BlockPos;\r\nimport net.minecraft.util.MathHelper;\r\nimport org.lwjgl.input.Keyboard;\r\n\r\nimport java.awt.*;\r\nimport java.math.BigDecimal;\r\nimport java.math.RoundingMode;\r\nimport java.util.ArrayDeque;\r\nimport java.util.Deque;\r\nimport java.util.Objects;\r\n\r\nimport static dev.risas.module.impl.movement.Fly.roundToOnGround;\r\n\r\n/**\r\n * Gives you a boost of speed or an improved strafing.\r\n */\r\n@ModuleInfo(name = \"Speed\", description = \"Lets you move faster\", category = Category.MOVEMENT)\r\npublic final class Speed extends Module {\r\n\r\n    private final ModeSetting mode = new ModeSetting(\"Mode\", this, \"Custom\", \"Custom\", \"Mineplex\", \"Strafe Hop\",\r\n            \"Vulcan\", \"Mineplex Low\", \"Mineplex Smooth\", \"Hypixel\", \"Hypixel2\", \"Hypixel3\", \"Hypixel Smooth\", \"Cubecraft\", \"CraftPlay\", \"NCP\",\r\n            \"Timer Bypass\", \"Taka\", \"Verus\", \"Spartan\", \"Redesky\", \"Zonecraft\", \"Bridger Land\", \"Exempted Value\", \"NCP Latest\",\r\n            \"Convert Ground\", \"AAC 4 Simple\", \"Invadedlands\", \"Minemenclub Hop\", \"Intave\", \"Teleport\", \"Predictive\",\r\n            \"Vulcan2\"/*, \"Vape\", \"MineBox\"*/, \"BlocksMC\", \"KoksCraft\");\r\n    private final BooleanSetting craftplayTimer = new BooleanSetting(\"Timer\", this, false);\r\n    private final BooleanSetting koksStrafe = new BooleanSetting(\"Strafe\", this, false);\r\n    private final ModeSetting exemptedValueType = new ModeSetting(\"Value\", this, \"1\", \"1\", \"2\", \"3\");\r\n    private final ModeSetting vapeMode = new ModeSetting(\"Vape Mode\", this, \"AntiCheat A\", \"AntiCheat A\", \"AntiCheat B\", \"Bhop\", \"Y-Port\");\r\n    private final NumberSetting vapeSteps = new NumberSetting(\"Vape Steps\", this, 43.5, 10, 180, 0.1);\r\n    private final ModeSetting verusMode = new ModeSetting(\"Verus Mode\", this, \"Hop\", \"Hop\", \"Low\", \"Float\", \"YPort\");\r\n\r\n    private final ModeSetting groundSpoofMode = new ModeSetting(\"GroundSpoof\", this, \"Off\", \"Off\", \"On\", \"Air\", \"Tick\");\r\n    private final NumberSetting customSpeed = new NumberSetting(\"Custom Speed\", this, 0.35, 0.0, 4.0, 0.01);\r\n    private final NumberSetting customMotionY = new NumberSetting(\"Custom MotionY\", this, 0.42F, 0.0, 1.0, 0.01);\r\n    private final NumberSetting customFallMotion = new NumberSetting(\"Custom Fall Motion\", this, 0.4, 0.0, 1.0, 0.01);\r\n    private final NumberSetting fallTick = new NumberSetting(\"Custom Fall Tick\", this, 2, 0.0, 12, 1);\r\n    private final NumberSetting extraGround = new NumberSetting(\"Extra OnGround Packets\", this, 0, 0, 10, 1);\r\n    private final NumberSetting randomizeSpeed = new NumberSetting(\"Randomize Speed\", this, 0.0, 0.0, 10, 0.1);\r\n    private final NumberSetting voidTpTicks = new NumberSetting(\"Void TP Ticks\", this, 0.0, 0.0, 50, 1);\r\n    private final NumberSetting timer = new NumberSetting(\"Timer\", this, 1.0, 0.1, 10, 0.1);\r\n    private final NumberSetting timerRandom = new NumberSetting(\"Timer Random\", this, 0.0, 0.0, 10, 0.1);\r\n    private final NumberSetting groundSpoofTick = new NumberSetting(\"GroundSpoof Ticks\", this, 0.0, 0.0, 10, 1);\r\n\r\n    private final NumberSetting teleportDistance = new NumberSetting(\"Teleport Distance\", this, 0.03, 0.0, 1, 0.01);\r\n    private final BooleanSetting strafe = new BooleanSetting(\"Strafe\", this, false);\r\n\r\n    private final BooleanSetting mmcVL = new BooleanSetting(\"MMC VL Abuse\", this, false);\r\n\r\n    private final BooleanSetting friction = new BooleanSetting(\"Abide Friciton\", this, false);\r\n    private final BooleanSetting strafeOnGround = new BooleanSetting(\"Only Strafe On Ground\", this, false);\r\n    private final BooleanSetting groundDisabler = new BooleanSetting(\"Ground Disabler\", this, false);\r\n    private final BooleanSetting fastFall = new BooleanSetting(\"FastFall\", this, false);\r\n    private final BooleanSetting voidTP = new BooleanSetting(\"VoidTP\", this, false);\r\n    private final BooleanSetting voidTPMove = new BooleanSetting(\"VoidTP only Move\", this, false);\r\n    private final BooleanSetting cancelC0F = new BooleanSetting(\"Cancel C0F\", this, false);\r\n    private final BooleanSetting cancelC00 = new BooleanSetting(\"Cancel C00\", this, false);\r\n\r\n    private final NumberSetting speedTimer = new NumberSetting(\"Speed\", this, 2, 0.1, 6.0, 0.1);\r\n    private final NumberSetting pulse = new NumberSetting(\"Pulse\", this, 20, 4, 100, 0.1);\r\n\r\n    private final BooleanSetting damageBoost = new BooleanSetting(\"Damage Boost\", this, false);\r\n\r\n    private final NumberSetting speedMulti = new NumberSetting(\"Speed Multiplier\", this, 1.1, 1, 2, 0.1);\r\n    private final NumberSetting timerBoost = new NumberSetting(\"Timer Boost\", this, 1.1, 1, 4, 0.1);\r\n\r\n    private final NumberSetting tick = new NumberSetting(\"Tick\", this, 1, 0.0, 12, 0.1);\r\n    private final BooleanSetting groundSpoof = new BooleanSetting(\"GroundSpoof\", this, false);\r\n\r\n    private final BooleanSetting smoothCamera = new BooleanSetting(\"Hide Jumps\", this, false);\r\n\r\n    private final NumberSetting speedMultiplierNCP = new NumberSetting(\"Speed Multiplier No Speed\", this, 1.05, 1,\r\n            1.35, 0.01);\r\n    private final NumberSetting speedMultiplierNCPSpeed1 = new NumberSetting(\"Speed Multiplier Speed 1\", this, 1.05, 1\r\n            , 1.35, 0.01);\r\n    private final NumberSetting speedMultiplierNCPSpeed2 = new NumberSetting(\"Speed Multiplier Speed 2\", this, 1.05, 1\r\n            , 1.35, 0.01);\r\n    private final NumberSetting timerNcp = new NumberSetting(\"General Timer\", this, 1, 1, 1.4, 0.1);\r\n    private final NumberSetting speedInAirNcp = new NumberSetting(\"SpeedInAir No Speed\", this, 0.02, 0.02, 0.06, 0.01);\r\n    private final NumberSetting speedInAirNcpSpeed1 = new NumberSetting(\"SpeedInAir Speed 1\", this, 0.02, 0.02, 0.06,\r\n            0.01);\r\n    private final NumberSetting speedInAirNcpSpeed2 = new NumberSetting(\"SpeedInAir Speed 2\", this, 0.02, 0.02, 0.06,\r\n            0.01);\r\n    private final BooleanSetting smartTimer = new BooleanSetting(\"Smart Timer\", this, false);\r\n    private final BooleanSetting revertNcpSpeed = new BooleanSetting(\"Revert to fastest on default config\", this,\r\n            false);\r\n\r\n    private final NumberSetting howOften = new NumberSetting(\"How Often\", this, 1, 1, 50, 0.01);\r\n    private final NumberSetting distance = new NumberSetting(\"Distance\", this, 2, 2, 200, 0.01);\r\n\r\n    private final BooleanSetting disableOnFlag = new BooleanSetting(\"Disable on flag\", this, true);\r\n    private final BooleanSetting stopOnDisable = new BooleanSetting(\"Stop on Disable\", this, true);\r\n    private final BooleanSetting disableOnWorldChange = new BooleanSetting(\"Disable on World Change\", this, false);\r\n\r\n    private final BooleanSetting hypixeldamageBoost = new BooleanSetting(\"Damage Boost\", this, false);\r\n    private final NumberSetting hypixelTimer = new NumberSetting(\"Hypixel Timer\", this, 1, 1, 2.25, 0.05);\r\n    private final NumberSetting hypixelCombatTimer = new NumberSetting(\"Hypixel Combat Timer\", this, 1, 1, 2.25, 0.05);\r\n\r\n    private long balance, lastPreMotion;\r\n    private int ticks, offGroundTicks, onGroundTicks, stage, ticksDisable;\r\n    private double startY, speed;\r\n    private boolean jumped, bool, verusEpicBypassBooleanTM, touchedGround;\r\n    private final Deque<Packet<?>> packets = new ArrayDeque<>();\r\n\r\n    private float targetYaw;\r\n\r\n    boolean firstEnable;\r\n    private boolean boost;\r\n    private float lastYaw;\r\n    private float yaw;\r\n\r\n    // Vape AntiCheat A\r\n    private float v;\r\n    private int x = 0;\r\n\r\n    // Vape Speed parent\r\n    private double z, vapeSpeedVar;\r\n    private int parentX = 2;\r\n\r\n    private final TimeUtil stopwatch = new TimeUtil();\r\n\r\n    @Override\r\n    protected void onEnable() {\r\n        ticks = 0;\r\n        offGroundTicks = 0;\r\n        speed = 0;\r\n        onGroundTicks = 0;\r\n        startY = mc.thePlayer.posY;\r\n        packets.clear();\r\n\r\n        stage = 0;\r\n        verusEpicBypassBooleanTM = false;\r\n        touchedGround = false;\r\n        bool = false;\r\n        jumped = false;\r\n        ticksDisable = 60;\r\n//        switch (mode.getMode()) {\r\n//            case \"Hypixel\":\r\n//                targetYaw = mc.thePlayer.rotationYaw;\r\n//                break;\r\n//        }\r\n        if(mode.getMode().equals(\"KoksCraft\")) {\r\n            if(koksStrafe.isEnabled()) {\r\n                if (!firstEnable) {\r\n                    firstEnable = true;\r\n                    this.registerNotification(\"Strafe Is Flagless\");\r\n                }\r\n            }\r\n        }\r\n        if (mode.getMode().equals(\"Vape\") && vapeMode.getMode().equals(\"AntiCheat A\")) {\r\n            parentX = 1;\r\n            x = 0;\r\n            z = 0.0D;\r\n\r\n            double var1 = 0.2873F;\r\n            if (mc.thePlayer.isPotionActive(1) && mc.thePlayer.getActivePotionEffect(Potion.moveSpeed).getDuration() > 10) {\r\n                int var4 = mc.thePlayer.getActivePotionEffect(Potion.moveSpeed).getAmplifier();\r\n                var1 *= 1.0D + 0.15D * (double) (var4 + 1);\r\n            }\r\n\r\n            this.vapeSpeedVar = var1;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected void onDisable() {\r\n        boost = false;\r\n        mc.thePlayer.speedInAir = 0.02f;\r\n        mc.thePlayer.jumpMovementFactor = 0.02f;\r\n\r\n        mc.timer.timerSpeed = 1;\r\n\r\n        EntityPlayer.enableCameraYOffset = false;\r\n//        EntityPlayer.movementYaw = null;\r\n\r\n        if (stopOnDisable.isEnabled())\r\n            MoveUtil.stop();\r\n\r\n        if (packets.isEmpty()) return;\r\n\r\n        packets.forEach(PacketUtil::sendPacketWithoutEvent);\r\n        packets.clear();\r\n    }\r\n\r\n    @Override\r\n    public void onUpdateAlwaysInGui() {\r\n        fallTick.hidden = customFallMotion.hidden = !fastFall.isEnabled() || !mode.is(\"Custom\");\r\n\r\n        voidTPMove.hidden = voidTpTicks.hidden = !voidTP.isEnabled() || !mode.is(\"Custom\");\r\n\r\n        strafeOnGround.hidden = voidTP.hidden = groundSpoofTick.hidden = groundSpoofMode.hidden = cancelC00.hidden =\r\n                cancelC0F.hidden = timerRandom.hidden = randomizeSpeed.hidden = customSpeed.hidden =\r\n                        customMotionY.hidden = friction.hidden = groundDisabler.hidden = fastFall.hidden =\r\n                                customFallMotion.hidden = fallTick.hidden = extraGround.hidden = !mode.is(\"Custom\");\r\n\r\n        timer.hidden = !(mode.is(\"Vape\") || mode.is(\"Custom\"));\r\n\r\n        groundSpoofTick.hidden = !groundSpoofMode.is(\"Tick\") && mode.is(\"Custom\") || !mode.is(\"Custom\");\r\n\r\n        speedTimer.hidden = pulse.hidden = !mode.is(\"Timer Bypass\");\r\n\r\n        damageBoost.hidden = !mode.is(\"Verus\") || !verusMode.is(\"Hop\");\r\n\r\n        speedMulti.hidden = timerBoost.hidden = !mode.is(\"NCP\");\r\n\r\n        craftplayTimer.hidden = !mode.is(\"CraftPlay\");\r\n\r\n        koksStrafe.hidden = !mode.is(\"KoksCraft\");\r\n\r\n        tick.hidden = strafe.hidden = groundSpoof.hidden = !mode.is(\"Exempted Value\");\r\n\r\n        strafe.hidden = !(mode.is(\"Strafe Hop\") || mode.is(\"Exempted Value\") || mode.is(\"Teleport\"));\r\n\r\n        verusMode.hidden = !(mode.is(\"Verus\"));\r\n\r\n        speedMultiplierNCP.hidden = speedMultiplierNCPSpeed1.hidden = speedMultiplierNCPSpeed2.hidden =\r\n                speedInAirNcp.hidden = speedInAirNcpSpeed1.hidden = speedInAirNcpSpeed2.hidden =\r\n                        revertNcpSpeed.hidden = !mode.is(\"NCP Latest\");\r\n        vapeMode.hidden = !mode.is(\"Vape\");\r\n        vapeSteps.hidden = !(mode.is(\"Vape\") && vapeMode.is(\"AntiCheat A\"));\r\n\r\n        timerNcp.hidden = !(mode.is(\"NCP Latest\") && !smartTimer.isEnabled());\r\n\r\n        smartTimer.hidden = !mode.is(\"NCP Latest\");\r\n\r\n        hypixelTimer.hidden = !mode.is(\"Hypixel\") && !mode.is(\"Hypixel2\") && !mode.is(\"Hypixel3\") && !mode.is(\"Hypixel Smooth\");\r\n\r\n        hypixelCombatTimer.hidden = !mode.is(\"Hypixel\") && !mode.is(\"Hypixel2\") && !mode.is(\"Hypixel3\") && !mode.is(\"Hypixel Smooth\");\r\n\r\n        hypixeldamageBoost.hidden = !mode.is(\"Hypixel2\");\r\n\r\n        howOften.hidden = distance.hidden = !mode.is(\"Convert Ground\");\r\n\r\n        exemptedValueType.hidden = !mode.is(\"Exempted Value\");\r\n\r\n        teleportDistance.hidden = !mode.is(\"Teleport\");\r\n\r\n        mmcVL.hidden = !mode.is(\"Minemenclub Hop\");\r\n\r\n        if (revertNcpSpeed.isEnabled()) {\r\n            revertNcpSpeed.setEnabled(false);\r\n\r\n            speedMultiplierNCP.setValue(1.07);\r\n            speedMultiplierNCPSpeed2.setValue(1.1);\r\n            speedMultiplierNCPSpeed1.setValue(1.1);\r\n            timerNcp.setValue(1.07);\r\n            speedInAirNcp.setValue(0.02);\r\n            speedInAirNcpSpeed1.setValue(0.025);\r\n            speedInAirNcpSpeed2.setValue(0.03);\r\n            smartTimer.setEnabled(true);\r\n        }\r\n\r\n        if (!Rise.devMode && mode.getMode().equals(\"Vape\")) mode.set(\"Custom\");\r\n    }\r\n\r\n    @Override\r\n    public void onUpdateAlways() {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void onPreMotion(final PreMotionEvent event) {\r\n\r\n        ++ticks;\r\n        ticksDisable++;\r\n\r\n        if (ticksDisable < 50) {\r\n            return;\r\n        }\r\n\r\n        if (ticksDisable == 50) onEnable();\r\n\r\n        if (mc.thePlayer.ticksExisted == 1) toggleModule();\r\n        if (Objects.requireNonNull(Rise.INSTANCE.getModuleManager().getModule(\"Fly\")).isEnabled()) return;\r\n\r\n        if (mc.thePlayer.onGround) {\r\n            offGroundTicks = 0;\r\n            onGroundTicks += 1;\r\n            if (!verusMode.is(\"Float\"))\r\n                startY = mc.thePlayer.posY - 0.01;\r\n        } else {\r\n            offGroundTicks += 1;\r\n            onGroundTicks = 0;\r\n        }\r\n\r\n        EntityPlayer.enableCameraYOffset = false;\r\n\r\n        if (mc.thePlayer.posY > startY && smoothCamera.isEnabled()) {\r\n            EntityPlayer.enableCameraYOffset = true;\r\n            EntityPlayer.cameraYPosition = startY;\r\n        }\r\n\r\n        switch (mode.getMode()) {\r\n\r\n            case \"Custom\":\r\n                if (MoveUtil.isMoving()) {\r\n                    final double randomConst =\r\n                            randomizeSpeed.getValue() < 0.1 ? 0.0 : randomDouble(0.0, randomizeSpeed.getValue() / 100);\r\n                    final double randomize = (random() < 0.5 ? -randomConst : randomConst);\r\n\r\n                    if (mc.thePlayer.onGround) {\r\n                        final double jumpValue = customMotionY.getValue();\r\n\r\n                        mc.thePlayer.motionY = (Math.abs(jumpValue - 0.42F) < 1.0E-3) ? 0.42f : jumpValue;\r\n\r\n                        if (friction.isEnabled()) {\r\n                            MoveUtil.strafe(customSpeed.getValue() + randomize);\r\n                        }\r\n\r\n                        if (groundDisabler.isEnabled()) {\r\n                            event.setGround(ticks % 2 == 0);\r\n                        }\r\n\r\n                        for (int i = 0; i < extraGround.getValue(); i++) {\r\n                            PacketUtil.sendPacketWithoutEvent(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true));\r\n                        }\r\n                    }\r\n\r\n                    if (!friction.isEnabled()) {\r\n                        if (strafeOnGround.isEnabled()) {\r\n                            if (mc.thePlayer.onGround) {\r\n                                MoveUtil.strafe(customSpeed.getValue() + randomize);\r\n                            }\r\n                        } else {\r\n                            MoveUtil.strafe(customSpeed.getValue() + randomize);\r\n                        }\r\n                    } else {\r\n                        if (strafeOnGround.isEnabled()) {\r\n                            if (mc.thePlayer.onGround) {\r\n                                MoveUtil.strafe();\r\n                            }\r\n                        } else {\r\n                            MoveUtil.strafe();\r\n                        }\r\n                    }\r\n\r\n                    if (fastFall.isEnabled()) {\r\n                        if (offGroundTicks == Math.round(fallTick.getValue())) {\r\n                            mc.thePlayer.motionY = -customFallMotion.getValue();\r\n                        }\r\n                    }\r\n                } else {\r\n                    mc.thePlayer.motionZ = mc.thePlayer.motionX = 0;\r\n                }\r\n\r\n                if (voidTP.isEnabled()) {\r\n                    if (voidTpTicks.getValue() >= 0.5 && ticks % Math.round(voidTpTicks.getValue()) == 0) {\r\n                        if (voidTPMove.isEnabled()) {\r\n                            if (MoveUtil.isMoving()) {\r\n                                mc.getNetHandler().addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX,\r\n                                        mc.thePlayer.posY - 16 - Math.random(), mc.thePlayer.posZ, event.isGround()));\r\n                            }\r\n                        } else {\r\n                            mc.getNetHandler().addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX,\r\n                                    mc.thePlayer.posY - 16 - Math.random(), mc.thePlayer.posZ, event.isGround()));\r\n                        }\r\n                    }\r\n                }\r\n\r\n                final float timerRandomConst = (float) (timerRandom.getValue() < 0.1 ? 0.0 :\r\n                        randomDouble(0.0, timerRandom.getValue() / 100)\r\n                );\r\n                final float timerRandomize = (random() < 0.5 ? -timerRandomConst : timerRandomConst);\r\n\r\n                final boolean timerReset = timer.getValue() - 1.0 < 1E-3 && timer.getValue() - 1.0 > -1E-3;\r\n\r\n                mc.timer.timerSpeed = timerReset ? 1.0F : (float) timer.getValue();\r\n                mc.timer.timerSpeed += timerRandomize;\r\n\r\n                switch (groundSpoofMode.getMode().toLowerCase()) {\r\n                    case \"off\":\r\n                        break;\r\n\r\n                    case \"on\": {\r\n                        event.setGround(true);\r\n                        break;\r\n                    }\r\n\r\n                    case \"air\": {\r\n                        event.setGround(false);\r\n                        break;\r\n                    }\r\n\r\n                    case \"tick\": {\r\n                        if (groundSpoofTick.getValue() > 0.5 && ticks % Math.round(groundSpoofTick.getValue()) == 0) {\r\n                            event.setGround(true);\r\n                        }\r\n\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case \"BlocksMC\":\r\n\r\n                if (mc.thePlayer.onGround) {\r\n                    ticks++;\r\n                    MoveUtil.strafe(MoveUtil.getBaseMoveSpeed());\r\n                    mc.thePlayer.jump();\r\n\r\n                    if (mc.thePlayer.isPotionActive(Potion.moveSpeed)) {\r\n                        MoveUtil.strafe(MoveUtil.getSpeed() * 1.2);\r\n                    }\r\n                }\r\n\r\n                mc.timer.timerSpeed = (float) (1.09f - Math.random() / 100f);\r\n\r\n                MoveUtil.strafe();\r\n\r\n                break;\r\n\r\n            case \"MineBox\": {\r\n                if (mc.thePlayer.onGround && MoveUtil.isMoving()) {\r\n                    mc.thePlayer.motionY = 0.42F;\r\n                    MoveUtil.strafe(MoveUtil.getBaseMoveSpeed() * 2);\r\n\r\n//                    PacketUtil.sendPacketWithoutEvent(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true));\r\n                }\r\n\r\n                MoveUtil.strafe();\r\n\r\n                break;\r\n            }\r\n\r\n            case \"Vulcan2\":\r\n                if (mc.thePlayer.onGround && !this.getModule(Scaffold.class).isEnabled() &&\r\n                        mc.thePlayer.motionY > -.2) {\r\n                    PacketUtil.sendPacket(new C03PacketPlayer.C04PacketPlayerPosition(\r\n                            (mc.thePlayer.posX + mc.thePlayer.lastTickPosX) / 2,\r\n                            ((mc.thePlayer.posY + mc.thePlayer.lastTickPosY) / 2) - 0.0784000015258789,\r\n                            (mc.thePlayer.posZ + mc.thePlayer.lastTickPosZ) / 2, false));\r\n                    PacketUtil.sendPacket(new C03PacketPlayer.C06PacketPlayerPosLook(\r\n                            (mc.thePlayer.posX + mc.thePlayer.lastTickPosX) / 2,\r\n                            (mc.thePlayer.posY + mc.thePlayer.lastTickPosY) / 2,\r\n                            (mc.thePlayer.posZ + mc.thePlayer.lastTickPosZ) /\r\n                                    2, mc.thePlayer.rotationYaw, mc.thePlayer.rotationPitch, true));\r\n\r\n                    PacketUtil.sendPacket(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX,\r\n                            mc.thePlayer.posY, mc.thePlayer.posZ, false));\r\n                    PacketUtil.sendPacket(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX,\r\n                            mc.thePlayer.posY - 0.0784000015258789, mc.thePlayer.posZ, false));\r\n                    PacketUtil.sendPacket(new C03PacketPlayer.C06PacketPlayerPosLook(mc.thePlayer.posX,\r\n                            mc.thePlayer.posY, mc.thePlayer.posZ, mc.thePlayer.rotationYaw,\r\n                            mc.thePlayer.rotationPitch, true));\r\n\r\n                    MoveUtil.strafe(MoveUtil.getBaseMoveSpeed() * 1.25 * 2);\r\n\r\n                } else if (offGroundTicks == 1) {\r\n                    MoveUtil.strafe(MoveUtil.getBaseMoveSpeed() * 0.91f);\r\n                }\r\n                break;\r\n\r\n            case \"CraftPlay\":\r\n                if (mc.thePlayer.onGround && MoveUtil.isMoving()) {\r\n                    mc.thePlayer.jump();\r\n                    MoveUtil.strafe(MoveUtil.getSpeed() * 1.01);\r\n                }\r\n                if (offGroundTicks == 5) {\r\n                    mc.thePlayer.motionY = -0.1964000015258789;\r\n                    speed = mc.thePlayer.motionY;\r\n                    mc.thePlayer.motionY = speed;\r\n                }\r\n                if(craftplayTimer.isEnabled()) {\r\n                    if (offGroundTicks == 8) {\r\n                        mc.timer.timerSpeed = 1.15f;\r\n                    }\r\n                    if (offGroundTicks == 1) {\r\n                        mc.timer.timerSpeed = 1f;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case \"Hypixel\":\r\n\r\n                final double xDist = mc.thePlayer.lastTickPosX - mc.thePlayer.posX;\r\n                final double zDist = mc.thePlayer.lastTickPosZ - mc.thePlayer.posZ;\r\n                final double lastDist = Math.sqrt(xDist * xDist + zDist * zDist);\r\n\r\n                if (MoveUtil.isMoving()) {\r\n\r\n                    // I cannot believe we have six full time developers and not a single one made this speed work in liquid\r\n                    // maybe because any of those developers dont give a shit\r\n                    if (mc.thePlayer.isInLiquid()) {\r\n                        if (mc.thePlayer.isInWater()) {\r\n                            mc.timer.timerSpeed = (float) (hypixelTimer.getValue() * 1.75);\r\n                            MoveUtil.strafe(MoveUtil.getBaseMoveSpeed() * 0.3);\r\n                        } else if (mc.thePlayer.isInLava()) {\r\n                            mc.timer.timerSpeed = (float) (hypixelTimer.getValue() * 2);\r\n                            MoveUtil.strafe(MoveUtil.getBaseMoveSpeed() * 0.25);\r\n                        }\r\n\r\n                        return;\r\n                    }\r\n\r\n                    mc.gameSettings.keyBindJump.setKeyPressed(false);\r\n                    mc.gameSettings.keyBindSneak.setKeyPressed(false);\r\n\r\n                    final double baseMoveSpeed = MoveUtil.getBaseMoveSpeed();\r\n                    //strafe check dont remove\r\n                    event.setYaw(getMovementDirection(mc.thePlayer.moveForward, mc.thePlayer.moveStrafing,\r\n                            mc.thePlayer.rotationYaw));\r\n\r\n                    if (!mc.thePlayer.onGround && mc.thePlayer.fallDistance < 0.24) {\r\n                        mc.thePlayer.motionY = this.lowHopYModification(mc.thePlayer.motionY, round(\r\n                                mc.thePlayer.posY - (int) mc.thePlayer.posY, 3, 0.001)) + Math.random() / 100000f;\r\n                    }\r\n\r\n                    if (mc.thePlayer.onGround) {\r\n                        boolean doInitialLowHop =\r\n                                !mc.thePlayer.isPotionActive(Potion.jump) && !mc.thePlayer.isCollidedHorizontally;\r\n\r\n                        mc.thePlayer.motionY = doInitialLowHop ? 0.4f : 0.42f;\r\n\r\n                        Block under = PlayerUtil.getBlockRelativeToPlayer(0, -1, 0);\r\n                        MoveUtil.strafe(baseMoveSpeed * 1.6);\r\n\r\n                        Block block = PlayerUtil.getBlockRelativeToPlayer(0, -1, 0);\r\n                        if (block instanceof BlockIce || block instanceof BlockPackedIce) {\r\n                            MoveUtil.strafe(baseMoveSpeed * 2);\r\n                        }\r\n                        bool = true;\r\n                    } else if (bool) {\r\n                        bool = false;\r\n\r\n                        final double bunny = (0.84 + Math.random() / 50f) * (lastDist - baseMoveSpeed);\r\n\r\n                        MoveUtil.strafe(lastDist - bunny);\r\n\r\n                        event.setY(event.getY() + Math.random() / 1000000);\r\n                    }\r\n                } else {\r\n                    if (mc.thePlayer.onGround) MoveUtil.stop();\r\n\r\n                    mc.gameSettings.keyBindJump.setKeyPressed(Keyboard.isKeyDown(mc.gameSettings.keyBindJump.getKeyCode()));\r\n                    mc.gameSettings.keyBindSneak.setKeyPressed(Keyboard.isKeyDown(mc.gameSettings.keyBindSneak.getKeyCode()));\r\n                }\r\n\r\n                mc.timer.timerSpeed = (float) (hypixelTimer.getValue() - Math.random() / 50);\r\n\r\n                if (mc.thePlayer.isCollidedHorizontally || mc.thePlayer.fallDistance > 0.8)\r\n                    MoveUtil.strafe(MoveUtil.getSpeed() * 0.9);\r\n\r\n                if (mc.thePlayer.isPotionActive(Potion.moveSpeed)) {\r\n                    if (mc.thePlayer.onGround) {\r\n                        mc.thePlayer.motionX *= 1.04 - Math.random() / 100;\r\n                        mc.thePlayer.motionZ *= 1.04 - Math.random() / 100;\r\n                    } else {\r\n                        mc.thePlayer.motionX *= 1.005 - Math.random() / 100;\r\n                        mc.thePlayer.motionZ *= 1.005 - Math.random() / 100;\r\n                    }\r\n                }\r\n\r\n                if (PlayerUtil.getBlockRelativeToPlayer(0,-1,0) instanceof BlockAir) {\r\n                    MoveUtil.strafe(MoveUtil.getSpeed() * 0.92);\r\n                }\r\n\r\n                break;\r\n\r\n            case \"KoksCraft\": {\r\n                if (mc.thePlayer.onGround && MoveUtil.isMoving()) {\r\n                    mc.thePlayer.jump();\r\n                    MoveUtil.strafe(MoveUtil.getSpeed() * (1.01));\r\n                    mc.timer.timerSpeed = 1f;\r\n                }\r\n                if (offGroundTicks == 6) {\r\n                    mc.thePlayer.motionY = -0.199999999999999;\r\n\r\n                    speed = mc.thePlayer.motionY;\r\n                    mc.thePlayer.motionY = speed;\r\n                }\r\n                //liquid check\r\n                if (mc.thePlayer.isInLiquid()) {\r\n                    if (mc.thePlayer.isInWater()) {\r\n                        MoveUtil.strafe(MoveUtil.getBaseMoveSpeed() * 0.35);\r\n                    } else if (mc.thePlayer.isInLava()) {\r\n                        MoveUtil.strafe(MoveUtil.getBaseMoveSpeed() * 0.3);\r\n                    }\r\n                }\r\n            }\r\n            //strafe\r\n            if(koksStrafe.isEnabled()) {\r\n                if (offGroundTicks == 3) {\r\n                    MoveUtil.strafe();\r\n                }\r\n            }\r\n            break;\r\n\r\n            case \"Predictive\":\r\n                if (mc.thePlayer.onGround) {\r\n                    mc.thePlayer.jump();\r\n                }\r\n\r\n                if (offGroundTicks == 2) {\r\n                    event.setGround(true);\r\n                    mc.thePlayer.motionY = -0.0784000015258789;\r\n                    mc.thePlayer.onGround = true;\r\n\r\n                    speed = mc.thePlayer.motionY;\r\n                    mc.thePlayer.jump();\r\n                    mc.thePlayer.motionY = speed;\r\n                }\r\n                break;\r\n\r\n            case \"Strafe Hop\":\r\n                if (mc.thePlayer.onGround && MoveUtil.isMoving()) {\r\n                    mc.thePlayer.jump();\r\n                }\r\n\r\n                if (strafe.isEnabled())\r\n                    MoveUtil.strafe();\r\n                break;\r\n\r\n            case \"Vulcan\":\r\n                if (MoveUtil.isMoving()) {\r\n                    if (mc.thePlayer.onGround) {\r\n\r\n                        double speed = MoveUtil.getBaseMoveSpeed() - 0.01;\r\n                        MoveUtil.strafe(speed - (Math.random() / 2000));\r\n\r\n                        mc.thePlayer.jump();\r\n\r\n                        bool = true;\r\n                    } else {\r\n                        if (bool) {\r\n                            if (offGroundTicks > 3)\r\n                                mc.thePlayer.motionY = MoveUtil.getPredictedMotionY(mc.thePlayer.motionY);\r\n\r\n                            if (!(PlayerUtil.getBlockRelativeToPlayer(0, 2, 0) instanceof BlockAir))\r\n                                MoveUtil.strafe(MoveUtil.getSpeed() * (1.1 - (Math.random() / 500)));\r\n                        }\r\n\r\n                        if (mc.thePlayer.isInLiquid() || mc.thePlayer.hurtTime == 9)\r\n                            MoveUtil.strafe();\r\n                    }\r\n                } else\r\n                    MoveUtil.stop();\r\n                break;\r\n\r\n            case \"Mineplex Low\":\r\n                ticks--;\r\n\r\n                if (mc.gameSettings.keyBindJump.isKeyDown()) {\r\n                    ticks = 0;\r\n                    return;\r\n                }\r\n\r\n                if (!jumped && mc.thePlayer.onGround) {\r\n                    mc.thePlayer.jump();\r\n                    mc.thePlayer.motionY = 0.21546;\r\n                    MoveUtil.strafe(0.1);\r\n                    jumped = true;\r\n                    ticks++;\r\n                }\r\n\r\n                if (!mc.thePlayer.onGround) {\r\n                    speed = (float) MoveUtil.getSpeed();\r\n                }\r\n\r\n                if (offGroundTicks == 1 && jumped) {\r\n                    MoveUtil.strafe(0.6);\r\n                }\r\n\r\n                if (jumped && mc.thePlayer.onGround) {\r\n                    MoveUtil.strafe(speed);\r\n                }\r\n\r\n                if (jumped)\r\n                    speed -= 0.009;\r\n\r\n                if (onGroundTicks > 2) {\r\n                    offGroundTicks = 0;\r\n                    jumped = false;\r\n                    speed = 0;\r\n                    onGroundTicks = 0;\r\n                    startY = mc.thePlayer.posY;\r\n                    packets.clear();\r\n                }\r\n\r\n                if (!MoveUtil.isMoving())\r\n                    ticks = 0;\r\n\r\n                MoveUtil.strafe();\r\n\r\n                break;\r\n\r\n            /**\r\n             * IMPORTANT TO ANYONE WHO SEES THIS:\r\n             *\r\n             * All raw, decompiled and unrefined sources from Vape V4.07\r\n             * This code is awful because it's been deobfuscated and decompiled.\r\n             * Please do not try to \"clean up\" or \"fix these\" sources. I don't care if warnings bother you\r\n             * This perfectly matches the original source.\r\n             *\r\n             * These only exist for testing, and my own curiosity/interest\r\n             *\r\n             * Private. These modes are only usable by developers.\r\n             * Do. Not. Share. This. Code.\r\n             * !!! Do not share that we have this source !!!\r\n             * Thank you.\r\n             *\r\n             * - Hazsi\r\n             */\r\n            case \"Vape\": {\r\n                switch (vapeMode.getMode()) {\r\n                    case \"AntiCheat A\": {\r\n                        double var1 = 0.2873F;\r\n                        if (mc.thePlayer.isPotionActive(1) && mc.thePlayer.getActivePotionEffect(Potion.moveSpeed).getDuration() > 10) {\r\n                            int var4 = mc.thePlayer.getActivePotionEffect(Potion.moveSpeed).getAmplifier();\r\n                            var1 *= 1.0D + 0.15D * (double) (var4 + 1);\r\n                        }\r\n\r\n                        if ((mc.thePlayer.movementInput.moveForward != 0 || mc.thePlayer.movementInput.moveStrafe != 0) && this.z > 0.0D && this.parentX > 0 && event.isGround()) {\r\n                            if (this.x > 0) {\r\n                                mc.thePlayer.motionY += 0.004999999888241291D + 9.999999747378752E-5D * Math.random();\r\n                            }\r\n\r\n                            ++this.x;\r\n                        }\r\n\r\n                        double var3 = mc.thePlayer.posX - mc.thePlayer.lastTickPosX;\r\n                        double var5 = mc.thePlayer.posZ - mc.thePlayer.lastTickPosZ;\r\n                        this.z = 0.1;\r\n\r\n                        if (this.parentX < 0) {\r\n                            ++this.parentX;\r\n                            this.z = 0.0D;\r\n                        } else {\r\n                            if ((mc.thePlayer.movementInput.moveForward == 0.0F && mc.thePlayer.movementInput.moveStrafe == 0.0F)) {\r\n                                this.vapeSpeedVar = var1;\r\n                            }\r\n\r\n                            boolean isMoving = mc.thePlayer.movementInput.moveForward != 0 || mc.thePlayer.movementInput.moveStrafe != 0;\r\n                            double var4 = vapeSpeedVar = var1;\r\n                            double var6;\r\n                            double var8;\r\n                            float var12;\r\n\r\n                            if (this.parentX == 1 && isMoving && mc.thePlayer.isCollidedVertically) {\r\n                                vapeSpeedVar = var1;\r\n                                this.x = 0;\r\n                            } else if (this.parentX == 2 && isMoving && mc.thePlayer.isCollidedVertically/* && mc.thePlayer.q()*/) {\r\n                                var6 = this.x > 0 ? 0.424F + 0.0001F * Math.random() : 0.42F;\r\n                                if (mc.thePlayer.isPotionActive(8)) {\r\n                                    var6 += (double) ((mc.thePlayer.getActivePotionEffect(Potion.jump).getAmplifier() + 1) * 0.1F);\r\n                                }\r\n\r\n//                                event.setY(event.getY() + var6);\r\n                                mc.thePlayer.motionY = var6;\r\n\r\n//                                vapeSpeedVar = var4 * 2.1475D;\r\n                                var8 = (double) mc.thePlayer.movementInput.moveForward;\r\n                                double var10 = (double) mc.thePlayer.movementInput.moveStrafe;\r\n                                var12 = mc.thePlayer.rotationYaw;\r\n\r\n                                if (var8 == 0.0D && var10 == 0.0D) {\r\n//                                    thePlayer.d(thePlayer.ae() + 1.0D, thePlayer.g(), thePlayer.Y() + 1.0D);\r\n//                                    thePlayer.d(thePlayer.x(), thePlayer.F(), thePlayer.aq());\r\n\r\n                                    mc.thePlayer.motionX = 0.0D;\r\n                                    mc.thePlayer.motionZ = 0.0D;\r\n\r\n//                                    if (thePlayer.q()) {\r\n//                                        this.v = var12;\r\n//                                    }\r\n                                } else if (var8 != 0.0D) {\r\n                                    if (var8 < 0.0D) {\r\n                                        var12 -= 180.0F;\r\n                                    }\r\n\r\n                                    if (var10 > 0.0D) {\r\n                                        var12 += var8 > 0.0D ? -43.51F : 43.51F;\r\n                                    } else if (var10 < 0.0D) {\r\n                                        var12 += var8 > 0.0D ? 43.51F : -43.51F;\r\n                                    }\r\n                                } else if (var10 > 0.0D) {\r\n                                    var12 += -88.58F;\r\n                                } else if (var10 < 0.0D) {\r\n                                    var12 += 88.58F;\r\n                                }\r\n\r\n                                float var13 = MathHelper.wrapAngleTo180_float(-(this.v - var12));\r\n                                float var14 = 180.0F;\r\n                                if (Math.abs(var13) >= var14) {\r\n                                    var13 = MathHelper.clamp_float(var13, -var14, var14);\r\n                                }\r\n\r\n                                this.v += var13;\r\n                            } else if (this.parentX == 3) {\r\n                                var6 = 0.825D;\r\n//                                if (thePlayer.b(fD.r())) {\r\n//                                    if (thePlayer.a(fD.r()).g() == 0) {\r\n//                                        var6 = 0.8D;\r\n//                                    } else {\r\n//                                        var6 = 0.75D;\r\n//                                    }\r\n//                                }\r\n\r\n                                var8 = var6 * (this.z - var4);\r\n                                this.vapeSpeedVar = this.z - var8;\r\n                            } else {\r\n//                                f1 var17;\r\n//                                if (FV.c() == 13) {\r\n//                                    var17 = thePlayer.ad().h().d(0.0D, thePlayer.aj(), 0.0D);\r\n//                                } else {\r\n//                                    var17 = thePlayer.ad().d(0.0D, thePlayer.aj(), 0.0D);\r\n//                                }\r\n//\r\n//                                List var7 = dE.P().a(thePlayer, var17);\r\n                                if (/*(var7.size() > 0 || */mc.thePlayer.isCollidedVertically && this.x > 0) {\r\n                                    this.parentX = mc.thePlayer.movementInput.moveForward == 0.0F && mc.thePlayer.movementInput.moveStrafe == 0.0F ? 0 : 1;\r\n                                }\r\n\r\n                                this.vapeSpeedVar = this.z - this.z / 159.0D;\r\n                            }\r\n\r\n                            this.vapeSpeedVar = Math.max(this.vapeSpeedVar, var4);\r\n                            if (this.parentX > 0) {\r\n                                var6 = (double) mc.thePlayer.movementInput.moveForward;\r\n                                var8 = (double) mc.thePlayer.movementInput.moveStrafe;\r\n                                float var18 = mc.thePlayer.rotationYaw;\r\n                                if (var6 == 0.0D && var8 == 0.0D) {\r\n                                    mc.thePlayer.motionX = 0.0D;\r\n                                    mc.thePlayer.motionZ = 0.0D;\r\n                                } else if (var6 != 0.0D) {\r\n                                    if (var8 > 0.0D) {\r\n                                        var18 += (float) (var6 > 0.0D ? -45 : 45);\r\n                                    } else if (var8 < 0.0D) {\r\n                                        var18 += (float) (var6 > 0.0D ? 45 : -45);\r\n                                    }\r\n\r\n                                    if (var6 > 0.0D) {\r\n                                        var6 = 1.0D;\r\n                                    } else if (var6 < 0.0D) {\r\n                                        var6 = 1.0D;\r\n                                        var18 -= 180.0F;\r\n                                    }\r\n                                } else {\r\n                                    if (var8 > 0.0D) {\r\n                                        var18 += -90.0F;\r\n                                    } else if (var8 < 0.0D) {\r\n                                        var18 += 90.0F;\r\n                                    }\r\n\r\n                                    var6 = 1.0D;\r\n                                }\r\n\r\n                                float var11 = MathHelper.wrapAngleTo180_float(-(this.v - var18));\r\n                                var12 = (float) this.vapeSteps.getValue();\r\n                                if (Math.abs(var11) >= var12) {\r\n                                    var11 = MathHelper.clamp_float(var11, -var12, var12);\r\n                                }\r\n\r\n                                this.v += var11;\r\n                                double var19 = Math.cos(Math.toRadians((double) (this.v + 90.0F)));\r\n                                double var15 = Math.sin(Math.toRadians((double) (this.v + 90.0F)));\r\n                                mc.thePlayer.motionX = var6 * vapeSpeedVar * var19;\r\n                                mc.thePlayer.motionZ = var6 * vapeSpeedVar * var15;\r\n\r\n                                if (mc.thePlayer.movementInput.moveForward != 0.0F || mc.thePlayer.movementInput.moveStrafe != 0.0F) {\r\n                                    ++this.parentX;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        break;\r\n                    }\r\n                    case \"AntiCheat B\": {\r\n                        double var2 = 0.4199999868869781494140625;\r\n\r\n                        if ((mc.thePlayer.movementInput.moveForward != 0 || mc.thePlayer.movementInput.moveStrafe != 0) && mc.thePlayer.isCollidedVertically) {\r\n                            mc.thePlayer.motionY = var2;\r\n                        }\r\n\r\n                        double var5 = (double) mc.thePlayer.movementInput.moveForward;\r\n                        double var7 = (double) mc.thePlayer.movementInput.moveStrafe;\r\n                        float var9 = mc.thePlayer.rotationYaw;\r\n\r\n                        if (var5 == 0.0D && var7 == 0.0D) {\r\n                            mc.thePlayer.motionX = 0.0D;\r\n                            mc.thePlayer.motionZ = 0.0D;\r\n                        } else if (var5 != 0.0D) {\r\n                            if (var7 != 0.0D) {\r\n                                if (var7 > 0.0D) {\r\n                                    var9 += var5 > 0.0D ? -45.0F : 45.0F;\r\n                                    var7 = 0.0D;\r\n                                } else {\r\n                                    var9 += var5 > 0.0D ? 45.0F : -45.0F;\r\n                                    var7 = 0.0D;\r\n                                }\r\n                            }\r\n\r\n                            if (var5 > 0.0D) {\r\n                                var5 = 1.0D;\r\n                            } else {\r\n                                var5 = -1.0D;\r\n                            }\r\n                        }\r\n\r\n                        double var10 = Math.cos(Math.toRadians(var9 + 90.0F));\r\n                        double var12 = Math.sin(Math.toRadians(var9 + 90.0F));\r\n                        mc.thePlayer.motionX = var5 * var2 * var10 + var7 * var2 * var12;\r\n                        mc.thePlayer.motionZ = var5 * var2 * var12 - var7 * var2 * var10;\r\n\r\n\r\n                        break;\r\n                    }\r\n                    case \"Y-Port\": {\r\n\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                break;\r\n            }\r\n            /**\r\n             * PLEASE READ THE ABOVE COMMENT BEFORE THIS MODE!\r\n             */\r\n\r\n            case \"Teleport\": {\r\n                if (!MoveUtil.isMoving()) return;\r\n\r\n                speed = teleportDistance.getValue();\r\n                final float yaw = (float) MoveUtil.getDirection();\r\n                final double posX = -MathHelper.sin(yaw) * speed + mc.thePlayer.posX;\r\n                final double posZ = MathHelper.cos(yaw) * speed + mc.thePlayer.posZ;\r\n\r\n                if (offGroundTicks > 1 && offGroundTicks < 11) mc.thePlayer.setPosition(posX, mc.thePlayer.posY, posZ);\r\n\r\n                if (mc.thePlayer.onGround) {\r\n                    mc.thePlayer.jump();\r\n                }\r\n                break;\r\n            }\r\n\r\n            case \"NCP\": {\r\n                if (MoveUtil.isMoving()) {\r\n                    if (mc.thePlayer.onGround) {\r\n                        mc.thePlayer.jump();\r\n                        MoveUtil.strafe(MoveUtil.getSpeed() * speedMulti.getValue() + Math.random() / 100);\r\n                    } else {\r\n                        MoveUtil.strafe(MoveUtil.getSpeed() * 1.0035);\r\n                    }\r\n\r\n                    mc.thePlayer.jumpMovementFactor = 0.02725F;\r\n                }\r\n\r\n                if (ticks < 20) {\r\n                    mc.timer.timerSpeed = 0.98f;\r\n                }\r\n\r\n                if (ticks == 20)\r\n                    ticks = 0;\r\n\r\n                if (ticks < 9) {\r\n                    mc.timer.timerSpeed = (float) (timerBoost.getValue() + Math.random() / 100);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case \"Taka\": {\r\n                if (MoveUtil.isMoving()) {\r\n                    if (mc.thePlayer.onGround) {\r\n                        mc.thePlayer.jump();\r\n                    } else {\r\n\r\n                        mc.thePlayer.speedInAir = (float) (0.02f + Math.random() / 300);\r\n                        if (mc.thePlayer.fallDistance > 0) {\r\n                            mc.thePlayer.motionY += 0.04;\r\n                        }\r\n\r\n                    }\r\n\r\n                    mc.timer.timerSpeed = (float) (1 + Math.random() / 3);\r\n                } else {\r\n                    mc.timer.timerSpeed = 1;\r\n                }\r\n                break;\r\n            }\r\n\r\n            case \"Spartan\": {\r\n                if (MoveUtil.isMoving()) {\r\n                    MoveUtil.strafe();\r\n\r\n                    mc.thePlayer.speedInAir = (float) (0.04 + Math.random() / 5000);\r\n\r\n                    if (mc.thePlayer.onGround) {\r\n                        mc.thePlayer.jump();\r\n                        ticks++;\r\n\r\n                        speed = 0.5 + Math.random() / 500;\r\n\r\n                        if (MoveUtil.getSpeed() < speed)\r\n                            MoveUtil.strafe(speed);\r\n                    }\r\n\r\n                    mc.thePlayer.setSprinting(false);\r\n                    mc.gameSettings.keyBindSprint.setKeyPressed(false);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case \"Redesky\": {\r\n\r\n                if (mc.thePlayer.onGround) {\r\n                    MoveUtil.strafe(0.5);\r\n                }\r\n\r\n                if (mc.thePlayer.ticksExisted % 40 == 0) {\r\n                    event.setY(event.getY() - 0.5);\r\n                    event.setGround(false);\r\n                    MoveUtil.strafe(0);\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            case \"Mineplex Smooth\": {\r\n\r\n                if (MoveUtil.isMoving()) {\r\n                    if (mc.thePlayer.onGround) {\r\n                        mc.thePlayer.jump();\r\n\r\n                        if (speed < 0.5)\r\n                            speed = 0.1f;\r\n                    } else {\r\n                        if (offGroundTicks == 1 && speed < 0.3) {\r\n                            speed = 0.55f;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (mc.thePlayer.hurtTime == 9) {\r\n                    speed = 0.7f;\r\n                }\r\n\r\n                speed -= speed / 70;\r\n\r\n\r\n                MoveUtil.strafe(speed);\r\n\r\n\r\n                break;\r\n            }\r\n            case \"Zonecraft\": {\r\n\r\n                if (mc.thePlayer.onGround) {\r\n                    mc.thePlayer.jump();\r\n                    MoveUtil.strafe(1);\r\n                }\r\n                mc.timer.timerSpeed = 0.9f;\r\n\r\n                if (offGroundTicks == 1) {\r\n                    mc.thePlayer.motionY = -0.0784000015258789;\r\n                }\r\n\r\n                MoveUtil.strafe();\r\n\r\n                /*\r\n                if (mc.thePlayer.onGround) {\r\n                    speed = (float) MoveUtil.getBaseMoveSpeed() + 0.1f;\r\n                    mc.thePlayer.jump();\r\n                }\r\n\r\n                speed -= speed / 79;\r\n                MoveUtil.strafe(speed);*/\r\n\r\n                break;\r\n            }\r\n            case \"Exempted Value\": {\r\n\r\n                if (mc.thePlayer.onGround) {\r\n                    mc.thePlayer.jump();\r\n                } else {\r\n                    if (offGroundTicks == (int) tick.getValue()) {\r\n                        double v = 0;\r\n                        switch (exemptedValueType.getMode()) {\r\n                            case \"1\":\r\n                                v = -0.0784000015258789;\r\n                                break;\r\n                            case \"2\":\r\n                                v = -0.09800000190734864;\r\n                                break;\r\n                            case \"3\":\r\n                                v = -0.09800000190735147;\r\n                                break;\r\n                        }\r\n\r\n                        mc.thePlayer.motionY = v;\r\n                        if (groundSpoof.isEnabled()) {\r\n                            event.setGround(true);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (strafe.isEnabled()) {\r\n                    MoveUtil.strafe();\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            case \"Convert Ground\": {\r\n\r\n                if (mc.thePlayer.ticksExisted % (int) howOften.getValue() == 0) {\r\n                    speed = (float) MoveUtil.getSpeed();\r\n\r\n                    final double direction2 = MoveUtil.getDirection();\r\n                    double posX2 = -Math.sin(direction2) * speed;\r\n                    double posZ2 = Math.cos(direction2) * speed;\r\n\r\n                    if (!MoveUtil.isMoving())\r\n                        posX2 = posZ2 = 0;\r\n\r\n                    if (MoveUtil.isMoving())\r\n                        for (int i = 0; i <= (int) distance.getValue(); ++i) {\r\n\r\n                            MoveUtil.strafe(speed * (i + 1));\r\n                            PacketUtil.sendPacketWithoutEvent(new C03PacketPlayer.C06PacketPlayerPosLook(\r\n                                    mc.thePlayer.posX + posX2 * i, mc.thePlayer.posY,\r\n                                    mc.thePlayer.posZ + posZ2 * i, (float) (mc.thePlayer.rotationYaw + Math.random()\r\n                            ), (float) (mc.thePlayer.rotationPitch + Math.random()), mc.thePlayer.onGround));\r\n\r\n                        }\r\n\r\n\r\n                } else {\r\n                    MoveUtil.stop();\r\n                    MoveUtil.strafe(0.14);\r\n                    mc.timer.timerSpeed = 0.6f;\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n//            case \"Hypixel\": {\r\n//                event.setYaw(yaw);\r\n//                mc.thePlayer.renderYawOffset = yaw;\r\n//                mc.thePlayer.rotationYawHead = yaw;\r\n//\r\n//                EntityPlayer.movementYaw = yaw;\r\n//\r\n//                lastYaw = yaw;\r\n//                break;\r\n//            }\r\n\r\n            case \"Hypixel Smooth\": {\r\n                double deltaYaw = MathHelper.wrapAngleTo180_double(Math.toDegrees(MoveUtil.getDirection()) - lastYaw);\r\n//                double angle = lastYaw + deltaYaw / (4 - Math.abs(deltaYaw / 90));\r\n                double maxAngle = 20;\r\n                double angle = lastYaw + (deltaYaw > 0 ? maxAngle : -maxAngle);\r\n\r\n                if (Math.abs(deltaYaw) < maxAngle) angle = Math.toDegrees(MoveUtil.getDirection());\r\n\r\n//                Rise.addChatMessage(angle + \"    \" + Math.abs(deltaYaw));\r\n//                Rise.addChatMessage(\"ANGLE: \" + angle + \"   DELTA: \" + deltaYaw + \"   LAST: \" + lastYaw);\r\n\r\n                boolean hasSpeed = mc.thePlayer.isPotionActive(Potion.moveSpeed);\r\n                int speedLevel =\r\n                        hasSpeed ? (mc.thePlayer.getActivePotionEffect(Potion.moveSpeed).getAmplifier() + 1) : 0;\r\n                mc.thePlayer.setSprinting(true);\r\n                mc.timer.timerSpeed =\r\n                        (mc.thePlayer.motionX == 0 && mc.thePlayer.motionZ == 0) ? 1 : (float) hypixelTimer.getValue();\r\n\r\n                if (mc.thePlayer.onGround && MoveUtil.isMoving()) {\r\n                    stage = (int) Math.round(mc.thePlayer.posY);\r\n                    mc.thePlayer.jump();\r\n                    mc.thePlayer.motionY -= 0.02;\r\n\r\n                    double groundSpeed = 0.47;\r\n                    groundSpeed += speedLevel * 0.15;\r\n\r\n                    angle = lastYaw = (float) Math.toDegrees(MoveUtil.getDirection());\r\n\r\n                    MoveUtil.strafe(groundSpeed, Math.toRadians(angle));\r\n                }\r\n                if (MoveUtil.isMoving()) {\r\n                    KeyBinding.setKeyBindState(mc.gameSettings.keyBindJump.getKeyCode(), false);\r\n                    MoveUtil.strafe(MoveUtil.getSpeed(), Math.toRadians(angle));\r\n\r\n                    if (MoveUtil.getSpeed() < 0.2) {\r\n                        MoveUtil.strafe(Math.max(0.05, MoveUtil.getSpeed() * 1.1));\r\n                    }\r\n                    if (MoveUtil.getSpeed() < 0.05) {\r\n                        //angle = strafeAngle = MoveUtil.getDirection();\r\n                    }\r\n                } else {\r\n                    KeyBinding.setKeyBindState(mc.gameSettings.keyBindJump.getKeyCode(), (\r\n                            Keyboard.isKeyDown(mc.gameSettings.keyBindJump.getKeyCode()) && mc.currentScreen == null\r\n                    ));\r\n                }\r\n\r\n                mc.thePlayer.jumpMovementFactor = 0.028f;\r\n                lastYaw = MathHelper.wrapAngleTo180_float((float) angle);\r\n                event.setYaw((float) angle);\r\n//                mc.thePlayer.renderYawOffset = mc.thePlayer.rotationYawHead = event.getYaw();\r\n\r\n                break;\r\n            }\r\n\r\n            case \"AAC 4 Simple\": {\r\n\r\n                mc.timer.timerSpeed = 1.02f;\r\n                if (mc.thePlayer.onGround && MoveUtil.isMoving()) {\r\n                    mc.thePlayer.jump();\r\n                    mc.thePlayer.motionZ *= 1.05;\r\n                    mc.thePlayer.motionX *= 1.05;\r\n                    mc.thePlayer.motionY = MoveUtil.getJumpMotion(0.4F);\r\n                }\r\n\r\n\r\n                break;\r\n            }\r\n            case \"Invadedlands\": {\r\n\r\n                if (mc.thePlayer.onGround) {\r\n                    mc.thePlayer.jump();\r\n                    mc.thePlayer.motionY = 0.1;\r\n                    MoveUtil.strafe(5);\r\n                } else {\r\n                    MoveUtil.stop();\r\n                    MoveUtil.strafe(MoveUtil.getBaseMoveSpeedOther() * 0.4);\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            case \"Intave\":\r\n                if (mc.thePlayer.onGround) {\r\n                    MoveUtil.strafe(MoveUtil.getBaseMoveSpeed() * 1.2);\r\n                    mc.thePlayer.jump();\r\n                } else if (offGroundTicks == 4) {\r\n                    mc.thePlayer.motionY = -0.0784000015258789;\r\n                }\r\n\r\n                MoveUtil.strafe();\r\n                break;\r\n            case \"Mineplex\":\r\n                if (mc.thePlayer.onGround) {\r\n                    MoveUtil.strafe(0);\r\n                }\r\n                if (ticks < 0) {\r\n                    Rise.addChatMessage(\"gliding\");\r\n//                    mc.thePlayer.motionY += 0.0355f;\r\n                }\r\n                break;\r\n            case \"Minemenclub Hop\":\r\n\r\n                if (mc.thePlayer.onGround) {\r\n                    mc.thePlayer.jump();\r\n                }\r\n\r\n                MoveUtil.strafe();\r\n                break;\r\n        }\r\n\r\n        if (mode.is(\"Verus\"))\r\n            switch (verusMode.getMode()) {\r\n                case \"Hop\":\r\n                    if (mc.thePlayer.onGround) {\r\n                        mc.thePlayer.jump();\r\n                        MoveUtil.strafe(0.55);\r\n                    } else {\r\n                        MoveUtil.strafe(0.349);\r\n                    }\r\n\r\n                    if (stopwatch.hasReached(200)) {\r\n                        PacketUtil.sendPacketWithoutEvent(new C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.START_SNEAKING));\r\n                        PacketUtil.sendPacketWithoutEvent(new C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.STOP_SPRINTING));\r\n                        stopwatch.reset();\r\n                    }\r\n                    break;\r\n\r\n                case \"Float\": {\r\n                    if (!mc.gameSettings.keyBindJump.isKeyDown()) {\r\n                        if (mc.thePlayer.onGround) {\r\n                            event.setGround(true);\r\n                            ticks = 0;\r\n                            MoveUtil.strafe(0.44f);\r\n                            mc.thePlayer.motionY = 0.42F;\r\n                            mc.timer.timerSpeed = 2.1f;\r\n\r\n                        } else {\r\n\r\n                            if (ticks >= 10) {\r\n                                verusEpicBypassBooleanTM = true;\r\n                                MoveUtil.strafe(0.2865f);\r\n                                return;\r\n                            }\r\n\r\n                            if (verusEpicBypassBooleanTM) {\r\n                                if (ticks <= 1) {\r\n                                    MoveUtil.strafe(0.45f);\r\n                                }\r\n\r\n                                if (ticks >= 2) {\r\n                                    MoveUtil.strafe(0.69f - (ticks - 2) * 0.019f);\r\n                                }\r\n                            }\r\n\r\n                            mc.thePlayer.motionY = 0;\r\n                            mc.timer.timerSpeed = 0.9f;\r\n\r\n                            event.setGround(true);\r\n                            mc.thePlayer.onGround = true;\r\n                        }\r\n                    }\r\n\r\n                    break;\r\n                }\r\n            }\r\n\r\n        if (!hypixelCombatTimer.hidden && Aura.target != null) {\r\n            mc.timer.timerSpeed = (float) hypixelCombatTimer.getValue();\r\n        }\r\n    }\r\n\r\n//    @Override\r\n//    public void onRender3DEvent(final Render3DEvent event) {\r\n//        if (mode.is(\"Hypixel\")) {\r\n//            targetYaw = (float) (MoveUtil.getDirection() * (180 / Math.PI));\r\n//            this.calculateHypixelYaw();\r\n//        }\r\n//    }\r\n//\r\n//    private void calculateHypixelYaw() {\r\n//        final int fps = (int) (Minecraft.getDebugFPS() / 20.0F);\r\n//\r\n//        final float rotationSpeed = 15 * 6F / fps;\r\n//\r\n//        final float deltaYaw = (((targetYaw - lastYaw) + 540) % 360) - 180;\r\n//\r\n//        final float distanceYaw = MathHelper.clamp_float(deltaYaw, -rotationSpeed, rotationSpeed);\r\n//\r\n//        yaw = lastYaw + distanceYaw;\r\n//\r\n//        final float[] currentRotations = new float[]{yaw, mc.thePlayer.rotationPitch};\r\n//        final float[] lastRotations = new float[]{lastYaw, mc.thePlayer.rotationPitch};\r\n//\r\n//        final float[] fixedRotations = RotationUtil.getFixedRotation(currentRotations, lastRotations);\r\n//\r\n//        yaw = fixedRotations[0];\r\n//    }\r\n\r\n    @Override\r\n    public void onBlockCollide(final BlockCollideEvent event) {\r\n//        switch (mode.getMode()) {\r\n//            case \"Verus\": {\r\n//                if (event.getBlock() instanceof BlockAir && !mc.thePlayer.isSneaking() && verusMode.getMode().equals(\"Hop\")) {\r\n//                    final double x = event.getX(), y = event.getY(), z = event.getZ();\r\n//\r\n//                    if (y < mc.thePlayer.posY) {\r\n//                        event.setCollisionBoundingBox(AxisAlignedBB.fromBounds(-15, -1, -15, 15, 1, 15).offset(x, y, z));\r\n//                    }\r\n//                }\r\n//            }\r\n//            break;\r\n//        }\r\n    }\r\n\r\n    public static double round(final double value, final int scale, final double inc) {\r\n        final double halfOfInc = inc / 2.0;\r\n        final double floored = Math.floor(value / inc) * inc;\r\n\r\n        if (value >= floored + halfOfInc)\r\n            return new BigDecimal(Math.ceil(value / inc) * inc)\r\n                    .setScale(scale, RoundingMode.HALF_UP)\r\n                    .doubleValue();\r\n        else return new BigDecimal(floored)\r\n                .setScale(scale, RoundingMode.HALF_UP)\r\n                .doubleValue();\r\n    }\r\n\r\n    public void onMove(final MoveEvent event) {\r\n\r\n        if (ticksDisable <= 20) {\r\n            return;\r\n        }\r\n\r\n        if (mode.is(\"Verus\"))\r\n            switch (verusMode.getMode()) {\r\n                case \"YPort\":\r\n                    if (MoveUtil.isMoving()) {\r\n                        if (mc.thePlayer.onGround) {\r\n                            MoveUtil.strafe(0.69);\r\n                            event.setY(0.42F);\r\n                            mc.thePlayer.motionY = 0;\r\n                        }\r\n                        MoveUtil.strafe(0.41);\r\n                    }\r\n                    break;\r\n\r\n                case \"Low\": {\r\n//                    Rise.addChatMessage(stage);\r\n\r\n//                    if (ticks % 10 == 0 && stage == 0) {\r\n//                        stage = 1;\r\n//                    } else {\r\n//                        switch (stage) {\r\n//                            case 0: {\r\n//                                MoveUtil.strafe(1);\r\n//                                break;\r\n//                            }\r\n//                            case 1: {\r\n//                                MoveUtil.strafe(0.0675);\r\n//                                break;\r\n//                            }\r\n//                            case 2: {\r\n//                                MoveUtil.strafe(0.0675);\r\n//                                break;\r\n//                            }\r\n//                            case 3: {\r\n//                                MoveUtil.strafe(0.066);\r\n//                                break;\r\n//                            }\r\n//                        }\r\n//\r\n//                        if (stage < 3 && stage != 0) {\r\n//                            stage++;\r\n//                        } else {\r\n//                            stage = 0;\r\n//                        }\r\n//                    }\r\n\r\n                    if (!MoveUtil.isMoving()) {\r\n                        return;\r\n                    }\r\n\r\n                    if (ticks % 12 == 0 && mc.thePlayer.onGround) {\r\n                        MoveUtil.strafe(0.69);\r\n                        event.setY(0.42F);\r\n//                        PacketUtil.sendPacketWithoutEvent(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY + 0.42F, mc.thePlayer.posZ, false));\r\n                        mc.thePlayer.motionY = -(mc.thePlayer.posY - roundToOnGround(mc.thePlayer.posY));\r\n                    } else {\r\n                        if (mc.thePlayer.onGround) {\r\n                            MoveUtil.strafe(1.01);\r\n                        } else {\r\n                            MoveUtil.strafe(0.41);\r\n                        }\r\n                    }\r\n\r\n                    break;\r\n                }\r\n            }\r\n\r\n        switch (mode.getMode()) {\r\n            case \"Mineplex\":\r\n\r\n                if (!MoveUtil.isMoving()) {\r\n                    if (mc.thePlayer.onGround) stage = 0;\r\n                    return;\r\n                }\r\n\r\n                if (mc.thePlayer.isCollidedHorizontally) {\r\n                    stage = 0;\r\n                }\r\n\r\n                if (mc.thePlayer.onGround) {\r\n                    event.setY(mc.thePlayer.motionY = 0.42f);\r\n                    stage++;\r\n                }\r\n\r\n                if (offGroundTicks == 1) {\r\n                    final float nextSpeed = 0.2f;\r\n                    speed += MoveUtil.getBaseMoveSpeed() / 2;\r\n                    if (speed > 1) speed = 1;\r\n                }\r\n\r\n                speed *= 0.985;\r\n\r\n//                if (offGroundTicks > 1 && offGroundTicks <= 15) mc.thePlayer.motionY += 0.02999;\r\n//\r\n//                if (offGroundTicks == 1) mc.thePlayer.motionY += 0.04f;\r\n//\r\n//                if (offGroundTicks == 17) mc.thePlayer.motionY -= 0.04f;\r\n\r\n                if (stage >= 1 && !mc.thePlayer.onGround) {\r\n                    final double baseSpeed = Math.max(MoveUtil.getBaseMoveSpeedOther(), speed);\r\n                    MoveUtil.setMoveEventSpeed(event, (Math.max(speed, baseSpeed)));\r\n                }\r\n\r\n                break;\r\n\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onPacketSend(final PacketSendEvent event) {\r\n        if (ticksDisable <= 20) {\r\n            return;\r\n        }\r\n\r\n        final Packet<?> p = event.getPacket();\r\n\r\n        switch (mode.getMode()) {\r\n            case \"Verus\": {\r\n                if (verusMode.is(\"Hop\") && p instanceof C0FPacketConfirmTransaction) {\r\n                    event.setCancelled(true);\r\n                }\r\n                break;\r\n            }\r\n            case \"Custom\":\r\n                if (cancelC0F.isEnabled()) {\r\n                    if (p instanceof C0FPacketConfirmTransaction) {\r\n                        event.setCancelled(true);\r\n                    }\r\n                }\r\n\r\n                if (cancelC00.isEnabled()) {\r\n                    if (p instanceof C00PacketKeepAlive) {\r\n                        event.setCancelled(true);\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case \"MineBox\":\r\n                if (PlayerUtil.generalAntiPacketLog() && PlayerUtil.isOnServer(\"minebox\") && p instanceof C03PacketPlayer) {\r\n                    event.setCancelled(true);\r\n                }\r\n                break;\r\n\r\n//            case \"Verus\": {\r\n//                if (event.getPacket() instanceof C03PacketPlayer.C04PacketPlayerPosition && verusMode.getMode().equals(\"Hop\")) {\r\n//                    C03PacketPlayer.C04PacketPlayerPosition packet = (C03PacketPlayer.C04PacketPlayerPosition) event.getPacket();\r\n//\r\n//                    switch (stage) {\r\n//                        case 1: {\r\n//                            packet.setY(packet.getY() + 0.42F);\r\n//                            packet.setOnGround(false);\r\n//                            break;\r\n//                        }\r\n//                        case 2: {\r\n//                            packet.setY(packet.getY() + 0.3415999853611);\r\n//                            packet.setOnGround(false);\r\n//                            break;\r\n//                        }\r\n//                        case 3: {\r\n//                            packet.setY(packet.getY() + 0.1863679808445);\r\n//                            packet.setOnGround(false);\r\n//                            break;\r\n//                        }\r\n//                    }\r\n//\r\n//                    event.setPacket(packet);\r\n////                    Rise.addChatMessage(stage + \"   \" + packet.getPositionY());\r\n//                }\r\n//            }\r\n        }\r\n\r\n        if (!mode.is(\"Timer Bypass\") || mc.isIntegratedServerRunning() || mc.thePlayer == null || mc.thePlayer.isDead)\r\n            return;\r\n\r\n        if (mc.thePlayer.ticksExisted < 10) {\r\n            packets.clear();\r\n            mc.timer.timerSpeed = 1;\r\n            return;\r\n        }\r\n\r\n        mc.timer.timerSpeed = (float) speedTimer.getValue();\r\n\r\n        packets.add(p);\r\n\r\n        event.setCancelled(true);\r\n\r\n        if (!packets.isEmpty() && mc.thePlayer.ticksExisted % (int) pulse.getValue() != 0) return;\r\n\r\n        packets.forEach(PacketUtil::sendPacketWithoutEvent);\r\n        packets.clear();\r\n\r\n    }\r\n\r\n    @Override\r\n    public void onStrafe(final StrafeEvent event) {\r\n        if (ticksDisable <= 20) {\r\n            return;\r\n        }\r\n\r\n        if (mode.getMode().toLowerCase().contains(\"ncp\")) {\r\n            MoveUtil.strafe();\r\n        }\r\n\r\n        switch (mode.getMode()) {\r\n\r\n            case \"Strafe\":\r\n                MoveUtil.strafe();\r\n                break;\r\n\r\n            case \"Vulcan\":\r\n                if (offGroundTicks <= 2) MoveUtil.strafe();\r\n                break;\r\n\r\n            case \"Cubecraft\":\r\n                if (MoveUtil.isMoving()) {\r\n                    final double baseSpeed = MoveUtil.getBaseMoveSpeed();\r\n                    switch (offGroundTicks) {\r\n                        case 0:\r\n                            if (mc.thePlayer.onGround) {\r\n                                /*\r\n                                 * Sets speed on ground\r\n                                 */\r\n                                speed = baseSpeed * (1.9 - (Math.random() / 500));\r\n\r\n                                /*\r\n                                 * Automatically jumps\r\n                                 */\r\n                                mc.thePlayer.motionY = MoveUtil.getJumpMotion(0.42F);\r\n                            }\r\n                            break;\r\n\r\n                        case 5:\r\n                            /*\r\n                             * Makes you go down faster\r\n                             */\r\n                            mc.thePlayer.motionY = MoveUtil.getPredictedMotionY(mc.thePlayer.motionY);\r\n                            break;\r\n                    }\r\n\r\n                    /*\r\n                     * Sets the timer speed\r\n                     */\r\n                    mc.timer.timerSpeed = (float) (1.1 - Math.random() / 100);\r\n\r\n                    /*\r\n                     * Sets the players speed\r\n                     */\r\n                    if (mc.thePlayer.onGround) {\r\n                        event.setFriction((float) Math.max(baseSpeed,\r\n                                event.getForward() != 0 && event.getStrafe() != 0 ? speed * 0.91F : speed));\r\n                        MoveUtil.stop();\r\n                    } else\r\n                        MoveUtil.strafe();\r\n                } else if (mc.currentScreen == null) {\r\n                    MoveUtil.stop();\r\n                    mc.timer.timerSpeed = 1;\r\n                }\r\n                break;\r\n\r\n            case \"Hypixel2\":\r\n                if(hypixeldamageBoost.isEnabled() && !mc.thePlayer.onGround) {\r\n                    if (mc.thePlayer.hurtTime > 0 && mc.thePlayer.hurtTime < 5) {\r\n                        boost = true;\r\n                        if (boost && !mc.thePlayer.isPotionActive(Potion.moveSpeed)) {\r\n                            MoveUtil.strafe(MoveUtil.getBaseMoveSpeed() * 1.7 - (mc.thePlayer.hurtTime / 10) - Math.random() / 100f);\r\n                        } else if (mc.thePlayer.isPotionActive(Potion.moveSpeed)) {\r\n                            MoveUtil.strafe(MoveUtil.getBaseMoveSpeed() * 1.6 - (mc.thePlayer.hurtTime / 10) - Math.random() / 100f);\r\n                        }\r\n                    } else {\r\n                        boost = false;\r\n                    }\r\n                }\r\n                if (mc.thePlayer.onGround && MoveUtil.isMoving()) {\r\n                    MoveUtil.strafe(MoveUtil.getAllowedHorizontalDistance() - Math.random() / 100);\r\n                    mc.thePlayer.jump();\r\n\r\n                    if (mc.thePlayer.isPotionActive(Potion.moveSpeed)) {\r\n                        MoveUtil.strafe(MoveUtil.getSpeed() * 1.1 - Math.random() / 100);\r\n                    }\r\n                }\r\n\r\n                double motionX = mc.thePlayer.motionX;\r\n                double motionZ = mc.thePlayer.motionZ;\r\n\r\n                MoveUtil.strafe();\r\n\r\n                if (!mc.thePlayer.onGround) {\r\n                    mc.thePlayer.motionX = (mc.thePlayer.motionX * 3 + motionX) / 4;\r\n                    mc.thePlayer.motionZ = (mc.thePlayer.motionZ * 3 + motionZ) / 4;\r\n                }\r\n\r\n                if (mc.thePlayer.isPotionActive(Potion.moveSpeed)) {\r\n                    MoveUtil.strafe(MoveUtil.getSpeed() * 1.03 - Math.random() / 100);\r\n                }\r\n\r\n                mc.timer.timerSpeed = (float) hypixelTimer.getValue();\r\n                break;\r\n            case \"Hypixel3\":\r\n                if (mc.thePlayer.onGround && MoveUtil.isMoving()) {\r\n                    MoveUtil.strafe(MoveUtil.getAllowedHorizontalDistance() - Math.random() / 100);\r\n                    if (mc.thePlayer.isPotionActive(Potion.moveSpeed)) {\r\n                        MoveUtil.strafe(MoveUtil.getSpeed() * 1.1 - Math.random() / 100);\r\n                    }\r\n                    mc.thePlayer.jump();\r\n\r\n                }\r\n                if (mc.thePlayer.motionY < 0.1D && mc.thePlayer.motionY > -0.21D && mc.thePlayer.motionY != 0) {\r\n                    mc.thePlayer.motionY -= 0.05D;\r\n\r\n                }\r\n\r\n                MoveUtil.strafe();\r\n\r\n\r\n                if (offGroundTicks == 5) {\r\n                    mc.thePlayer.motionY = MoveUtil.getPredictedMotionY(mc.thePlayer.motionY);\r\n                }\r\n\r\n                if (mc.thePlayer.isPotionActive(Potion.moveSpeed)) {\r\n                }\r\n                if (mc.thePlayer.hurtTime > 0) {\r\n                    MoveUtil.strafe(MoveUtil.getSpeed() * 1.03 - Math.random() / 100);\r\n                }\r\n\r\n                mc.timer.timerSpeed = (float) hypixelTimer.getValue();\r\n                break;\r\n\r\n\r\n            case \"Teleport\":\r\n                if (strafe.isEnabled()) MoveUtil.strafe();\r\n                break;\r\n\r\n            case \"NCP Latest\":\r\n                mc.timer.timerSpeed = (float) timerNcp.getValue();\r\n\r\n                if (mc.thePlayer.onGround && MoveUtil.isMoving()) {\r\n                    mc.thePlayer.jump();\r\n                    mc.thePlayer.motionY = MoveUtil.getJumpMotion((float) (0.4 + Math.random() / 500));\r\n\r\n                    mc.thePlayer.speedInAir = (float) speedInAirNcp.getValue();\r\n                    if (mc.thePlayer.isPotionActive(Potion.moveSpeed) &&\r\n                            (mc.thePlayer.getActivePotionEffect(Potion.moveSpeed).getAmplifier() + 1) == 2) {\r\n                        mc.thePlayer.motionX *= speedMultiplierNCPSpeed2.getValue();\r\n                        mc.thePlayer.motionZ *= speedMultiplierNCPSpeed2.getValue();\r\n                        mc.thePlayer.speedInAir = (float) speedInAirNcpSpeed2.getValue();\r\n                    } else if (mc.thePlayer.isPotionActive(Potion.moveSpeed) &&\r\n                            (mc.thePlayer.getActivePotionEffect(Potion.moveSpeed).getAmplifier() + 1) == 1) {\r\n                        mc.thePlayer.motionX *= speedMultiplierNCPSpeed1.getValue();\r\n                        mc.thePlayer.motionZ *= speedMultiplierNCPSpeed1.getValue();\r\n                        mc.thePlayer.speedInAir = (float) speedInAirNcpSpeed1.getValue();\r\n                    } else {\r\n                        mc.thePlayer.motionX *= speedMultiplierNCP.getValue();\r\n                        mc.thePlayer.motionZ *= speedMultiplierNCP.getValue();\r\n                    }\r\n                }\r\n\r\n                if (MoveUtil.isMoving() && smartTimer.isEnabled()) {\r\n                    float timerSpeed = (float) (1.1 + 0.5 - MoveUtil.getSpeed());\r\n\r\n                    if (!jumped) {\r\n                        timerSpeed = (float) (1.337 - MoveUtil.getSpeed());\r\n                    }\r\n\r\n                    if (mc.thePlayer.isPotionActive(Potion.moveSpeed)) {\r\n                        timerSpeed += (mc.thePlayer.getActivePotionEffect(Potion.moveSpeed).getAmplifier() + 1) / 12f;\r\n                    }\r\n\r\n                    if (timerSpeed > 1.5) timerSpeed = 1.5f;\r\n                    if (timerSpeed < 0.6) timerSpeed = 0.6f;\r\n                    mc.timer.timerSpeed = timerSpeed;\r\n                }\r\n\r\n                MoveUtil.strafe();\r\n\r\n                break;\r\n\r\n            case \"Hypixel\":\r\n                double motionX2 = mc.thePlayer.motionX;\r\n                double motionZ2 = mc.thePlayer.motionZ;\r\n\r\n                MoveUtil.strafe();\r\n\r\n                if (!mc.thePlayer.onGround && offGroundTicks != 1) {\r\n                    mc.thePlayer.motionX = (mc.thePlayer.motionX * 3 + motionX2) / 4;\r\n                    mc.thePlayer.motionZ = (mc.thePlayer.motionZ * 3 + motionZ2) / 4;\r\n                }\r\n\r\n                mc.thePlayer.motionX *= 0.99;\r\n                mc.thePlayer.motionZ *= 0.99;\r\n                break;\r\n        }\r\n    }\r\n\r\n    public float getMovementDirection(float forward, float strafing, float yaw) {\r\n        if (forward == 0.0F && strafing == 0.0F) return yaw;\r\n        boolean reversed = (forward < 0.0F);\r\n        float strafingYaw = 90.0F * ((forward > 0.0F) ? 0.5F : (reversed ? -0.5F : 1.0F));\r\n        if (reversed) yaw += 180.0F;\r\n        if (strafing > 0.0F) {\r\n            yaw -= strafingYaw;\r\n        } else if (strafing < 0.0F) {\r\n            yaw += strafingYaw;\r\n        }\r\n        return yaw;\r\n    }\r\n\r\n    private double lowHopYModification(final double baseMotionY, final double yDistFromGround) {\r\n        if (yDistFromGround == lowhopy[0]) {\r\n            return 0.31;\r\n        } else if (yDistFromGround == lowhopy[1]) {\r\n            return 0.04;\r\n        } else if (yDistFromGround == lowhopy[2]) {\r\n            return -0.2;\r\n        } else if (yDistFromGround == lowhopy[3]) {\r\n            return -0.14;\r\n        } else if (yDistFromGround == lowhopy[4]) {\r\n            return -0.2;\r\n        }\r\n        return baseMotionY;\r\n    }\r\n\r\n    public static final double[] lowhopy = {\r\n            round(0.4, 3, 0.001),\r\n            round(0.71, 3, 0.001),\r\n            round(0.75, 3, 0.001),\r\n            round(0.55, 3, 0.001),\r\n            round(0.41, 3, 0.001),\r\n    };\r\n\r\n\r\n    @Override\r\n    public void onRender2DEvent(final Render2DEvent event) {\r\n        switch (mode.getMode()) {\r\n\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onWorldChanged(final WorldChangedEvent event) {\r\n        if (disableOnWorldChange.isEnabled()) {\r\n            this.toggleModule();\r\n            this.registerNotification(\"Disabled \" + this.getModuleInfo().name() + \" due to world change.\");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onPacketReceive(final PacketReceiveEvent event) {\r\n        if (ticksDisable <= 20) {\r\n            return;\r\n        }\r\n\r\n        final Packet<?> p = event.getPacket();\r\n        if (mc.thePlayer.ticksExisted <= 1)\r\n            return;\r\n\r\n        switch (mode.getMode()) {\r\n            case \"Zonecraft\":\r\n                if (mc.thePlayer.ticksExisted > 20) {\r\n                    if (p instanceof S08PacketPlayerPosLook) {\r\n                        event.setCancelled(true);\r\n                        mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(((S08PacketPlayerPosLook) p).x, ((S08PacketPlayerPosLook) p).y, ((S08PacketPlayerPosLook) p).z, true));\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case \"Minemenclub Hop\":\r\n                if (p instanceof S08PacketPlayerPosLook) {\r\n                    balance = 0;\r\n                }\r\n                break;\r\n\r\n            case \"Vulcan2\":\r\n                if (p instanceof S08PacketPlayerPosLook && mc.thePlayer.ticksExisted > 20) {\r\n                    S08PacketPlayerPosLook s08 = ((S08PacketPlayerPosLook) p);\r\n                    if (mc.thePlayer.getDistanceSq(s08.getX(), s08.getY(), s08.getZ()) < 25 * 4) {\r\n                        event.setCancelled(true);\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case \"Hypixel2\":\r\n\r\n                if (p instanceof S08PacketPlayerPosLook && mc.thePlayer.ticksExisted > 20) {\r\n                    if (!bool) {\r\n                        event.setCancelled(true);\r\n//                        Rise.addChatMessage(\"test\");\r\n                        bool = true;\r\n                    }\r\n                }\r\n\r\n                break;\r\n\r\n        }\r\n\r\n        if (p instanceof S08PacketPlayerPosLook && disableOnFlag.isEnabled()) {\r\n            ticksDisable = 0;\r\n\r\n            onDisable();\r\n            this.registerNotification(\"Temporarily disabled speed due to a teleport.\");\r\n        }\r\n\r\n        if (event.getPacket() instanceof S00PacketDisconnect) {\r\n            balance = 0;\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/dev/risas/module/impl/movement/Speed.java b/dev/risas/module/impl/movement/Speed.java
--- a/dev/risas/module/impl/movement/Speed.java	(revision 12f741f73fd2ba762ae96403a891020f2d06a691)
+++ b/dev/risas/module/impl/movement/Speed.java	(date 1727823403449)
@@ -35,6 +35,7 @@
 import net.minecraft.network.play.client.*;
 import net.minecraft.network.play.server.S08PacketPlayerPosLook;
 import net.minecraft.potion.Potion;
+import net.minecraft.potion.PotionEffect;
 import net.minecraft.util.AxisAlignedBB;
 import net.minecraft.util.BlockPos;
 import net.minecraft.util.MathHelper;
@@ -59,7 +60,7 @@
             "Vulcan", "Mineplex Low", "Mineplex Smooth", "Hypixel", "Hypixel2", "Hypixel3", "Hypixel Smooth", "Cubecraft", "CraftPlay", "NCP",
             "Timer Bypass", "Taka", "Verus", "Spartan", "Redesky", "Zonecraft", "Bridger Land", "Exempted Value", "NCP Latest",
             "Convert Ground", "AAC 4 Simple", "Invadedlands", "Minemenclub Hop", "Intave", "Teleport", "Predictive",
-            "Vulcan2"/*, "Vape", "MineBox"*/, "BlocksMC", "KoksCraft");
+            "Vulcan2"/*, "Vape", "MineBox"*/, "BlocksMC", "KoksCraft", "Trojan");
     private final BooleanSetting craftplayTimer = new BooleanSetting("Timer", this, false);
     private final BooleanSetting koksStrafe = new BooleanSetting("Strafe", this, false);
     private final ModeSetting exemptedValueType = new ModeSetting("Value", this, "1", "1", "2", "3");
@@ -99,6 +100,7 @@
     private final BooleanSetting damageBoost = new BooleanSetting("Damage Boost", this, false);
 
     private final NumberSetting speedMulti = new NumberSetting("Speed Multiplier", this, 1.1, 1, 2, 0.1);
+    private final NumberSetting trojanstrafe = new NumberSetting("Trojan Speed", this, 1.1, 0.1, 2, 0.1);
     private final NumberSetting timerBoost = new NumberSetting("Timer Boost", this, 1.1, 1, 4, 0.1);
 
     private final NumberSetting tick = new NumberSetting("Tick", this, 1, 0.0, 12, 0.1);
@@ -266,6 +268,8 @@
 
         hypixeldamageBoost.hidden = !mode.is("Hypixel2");
 
+        trojanstrafe.hidden = !mode.is("Trojan");
+
         howOften.hidden = distance.hidden = !mode.is("Convert Ground");
 
         exemptedValueType.hidden = !mode.is("Exempted Value");
@@ -295,6 +299,30 @@
 
     }
 
+    @Override
+    public void onUpdate(final UpdateEvent event) {
+        switch (mode.getMode()) {
+
+            case "Trojan":
+                mc.gameSettings.keyBindJump.setKeyPressed(false);
+                if (mc.thePlayer == null) return;
+                if (mc.thePlayer.isInWater() || mc.thePlayer.isInLava() || mc.thePlayer.isInWeb || mc.thePlayer.isOnLadder()) return;
+
+                if (MoveUtil.isMoving() && collides()) {
+                    MoveUtil.strafe(trojanstrafe.getValue());
+                    mc.thePlayer.motionY = 0.005;
+                }
+                break;
+       }
+    }
+
+    private boolean collides() {
+        if (mc.theWorld == null) return false;
+
+        if (mc.thePlayer == null) return false;
+
+        return !mc.theWorld.getCollidingBoundingBoxes(mc.thePlayer, mc.thePlayer.getEntityBoundingBox().offset(0.0, -0.005, 0.0)).isEmpty();
+    }
     @Override
     public void onPreMotion(final PreMotionEvent event) {
 
@@ -1529,6 +1557,12 @@
         final Packet<?> p = event.getPacket();
 
         switch (mode.getMode()) {
+            case "Trojan": {
+                if (p instanceof C03PacketPlayer && collides()) {
+                    ((C03PacketPlayer) p).y += 0.005;
+                }
+                break;
+            }
             case "Verus": {
                 if (verusMode.is("Hop") && p instanceof C0FPacketConfirmTransaction) {
                     event.setCancelled(true);
Index: dev/risas/module/impl/other/Disabler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/dev/risas/module/impl/other/Disabler.java b/dev/risas/module/impl/other/DisablerOld.java
rename from dev/risas/module/impl/other/Disabler.java
rename to dev/risas/module/impl/other/DisablerOld.java
--- a/dev/risas/module/impl/other/Disabler.java	(revision 12f741f73fd2ba762ae96403a891020f2d06a691)
+++ b/dev/risas/module/impl/other/DisablerOld.java	(date 1727748917626)
@@ -16,24 +16,17 @@
 import dev.risas.module.Module;
 import dev.risas.module.api.ModuleInfo;
 import dev.risas.module.enums.Category;
-import dev.risas.module.impl.movement.Fly;
-import dev.risas.module.impl.movement.LongJump;
-import dev.risas.module.impl.player.Scaffold;
 import dev.risas.notifications.NotificationType;
 import dev.risas.setting.Setting;
 import dev.risas.setting.impl.BooleanSetting;
 import dev.risas.setting.impl.NoteSetting;
 import dev.risas.util.math.MathUtil;
 import dev.risas.util.math.TimeUtil;
-import dev.risas.util.pathfinding.MainPathFinder;
-import dev.risas.util.player.MoveUtil;
 import dev.risas.util.player.PacketUtil;
 import dev.risas.util.player.PlayerUtil;
-import io.netty.buffer.Unpooled;
 import net.minecraft.client.entity.EntityPlayerSP;
 import net.minecraft.entity.player.PlayerCapabilities;
 import net.minecraft.network.Packet;
-import net.minecraft.network.PacketBuffer;
 import net.minecraft.network.play.client.*;
 import net.minecraft.network.play.server.*;
 import net.minecraft.util.*;
@@ -41,15 +34,14 @@
 
 import java.util.*;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
 /**
  * This module is designed to disable an anticheat or some of its checks
  * in order to make bypassing easier/having extreme bypasses.
  */
-@ModuleInfo(name = "Disabler", description = "Disables some servers AntiCheats", category = Category.OTHER)
-public final class Disabler extends Module {
+@ModuleInfo(name = "DisablerOld", description = "Disables some servers AntiCheats", category = Category.OTHER)
+public final class DisablerOld extends Module {
 
     private final NoteSetting modeSettings = new NoteSetting("Mode Settings", this);
     private final BooleanSetting hypixel = new BooleanSetting("Hypixel", this, false);
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
--- /dev/null	(date 1727748825509)
+++ b/.idea/vcs.xml	(date 1727748825509)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: dev/risas/event/EventHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package dev.risas.event;\r\n\r\nimport dev.risas.Rise;\r\nimport dev.risas.event.api.Event;\r\nimport dev.risas.event.impl.motion.MinimumMotionEvent;\r\nimport dev.risas.event.impl.motion.PostMotionEvent;\r\nimport dev.risas.event.impl.motion.PreMotionEvent;\r\nimport dev.risas.event.impl.motion.TeleportEvent;\r\nimport dev.risas.event.impl.other.*;\r\nimport dev.risas.event.impl.packet.PacketReceiveEvent;\r\nimport dev.risas.event.impl.packet.PacketSendEvent;\r\nimport dev.risas.event.impl.render.*;\r\nimport dev.risas.module.Module;\r\nimport dev.risas.module.impl.movement.Fly;\r\nimport dev.risas.module.impl.other.AntiCheat;\r\nimport dev.risas.module.impl.other.Disabler;\r\nimport dev.risas.module.impl.render.Interface;\r\nimport dev.risas.ui.clickgui.impl.ClickGUI;\r\nimport dev.risas.ui.clickgui.impl.strikeless.StrikeGUI;\r\nimport dev.risas.util.player.PlayerUtil;\r\nimport dev.risas.util.render.RenderUtil;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.entity.Entity;\r\nimport net.minecraft.entity.player.EntityPlayer;\r\n\r\nimport java.awt.*;\r\nimport java.util.Objects;\r\n\r\npublic final class EventHandler {\r\n\r\n    private static final Minecraft mc = Minecraft.getMinecraft();\r\n    private static EntityPlayer target = null;\r\n    public static boolean canUpdateDeaths;\r\n\r\n    public static void handle(final Event e) {\r\n        if (Rise.INSTANCE.destructed) return;\r\n        final Module[] modules = Rise.INSTANCE.getModuleManager().getModuleList();\r\n\r\n        if (e instanceof Render2DEvent) {\r\n            final Render2DEvent event = ((Render2DEvent) e);\r\n\r\n            RenderUtil.delta2DFrameTime = (System.currentTimeMillis() - RenderUtil.last2DFrame) / 10F;\r\n            RenderUtil.last2DFrame = System.currentTimeMillis();\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onRender2DEvent(event);\r\n                }\r\n            }\r\n        } else if (e instanceof Render3DEvent) {\r\n            final Render3DEvent event = ((Render3DEvent) e);\r\n\r\n            RenderUtil.delta3DFrameTime = (System.currentTimeMillis() - RenderUtil.last3DFrame) / 10F;\r\n            RenderUtil.last3DFrame = System.currentTimeMillis();\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onRender3DEvent(event);\r\n                }\r\n            }\r\n        } else if (e instanceof BlurEvent) {\r\n            final BlurEvent event = ((BlurEvent) e);\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onBlur(event);\r\n                }\r\n        }\r\n    } else if (e instanceof MouseOverEvent) {\r\n        final MouseOverEvent event = ((MouseOverEvent) e);\r\n\r\n        for (final Module module : modules) {\r\n            if (module.isEnabled()) {\r\n                module.onMouseOver(event);\r\n            }\r\n        }\r\n    } else if (e instanceof FadingOutlineEvent) {\r\n            final FadingOutlineEvent event = ((FadingOutlineEvent) e);\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onFadingOutline(event);\r\n                }\r\n            }\r\n        } else if (e instanceof Shader3DEvent) {\r\n            final Shader3DEvent event = ((Shader3DEvent) e);\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onShader3DEvent(event);\r\n                }\r\n            }\r\n        } else if (e instanceof PreBlurEvent) {\r\n            final PreBlurEvent event = ((PreBlurEvent) e);\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onPreBlur(event);\r\n                }\r\n            }\r\n        } else if (e instanceof PacketReceiveEvent) {\r\n            final PacketReceiveEvent event = ((PacketReceiveEvent) e);\r\n\r\n            if (Objects.requireNonNull(Rise.INSTANCE.getModuleManager().getModule(AntiCheat.class)).isEnabled())\r\n                Rise.INSTANCE.getAntiCheat().handle(event.getPacket());\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onPacketReceive(event);\r\n                }\r\n            }\r\n        } else if (e instanceof PacketSendEvent) {\r\n            final PacketSendEvent event = ((PacketSendEvent) e);\r\n\r\n            if (Objects.requireNonNull(Rise.INSTANCE.getModuleManager().getModule(AntiCheat.class)).isEnabled())\r\n                Rise.INSTANCE.getAntiCheat().handle(event.getPacket());\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onPacketSend(event);\r\n                }\r\n            }\r\n        } else if (e instanceof MinimumMotionEvent) {\r\n            final MinimumMotionEvent event = ((MinimumMotionEvent) e);\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onMinimumMotion(event);\r\n                }\r\n            }\r\n        } else if (e instanceof PostMotionEvent) {\r\n            final PostMotionEvent event = ((PostMotionEvent) e);\r\n\r\n            //Statistics\r\n            if (target != null && !mc.theWorld.playerEntities.contains(target) && mc.thePlayer.getDistance(target.posX, mc.thePlayer.posY, target.posZ) < 30) {\r\n                Rise.totalKills++;\r\n                target = null;\r\n            }\r\n\r\n            if (mc.thePlayer.ticksExisted == 1) {\r\n                PlayerUtil.worldChanges++;\r\n            }\r\n\r\n            final double d = mc.thePlayer.getDistance(mc.thePlayer.lastTickPosX, mc.thePlayer.posY, mc.thePlayer.lastTickPosZ);\r\n\r\n            Rise.amountOfModulesOn = 0;\r\n\r\n            if (mc.thePlayer.onGround)\r\n                Rise.distanceRan += d;\r\n            else if (!Objects.requireNonNull(Rise.INSTANCE.getModuleManager().getModule(\"Fly\")).isEnabled())\r\n                Rise.distanceJumped += d;\r\n\r\n            if (mc.thePlayer.getHealth() <= 0) {\r\n                if (canUpdateDeaths) {\r\n                    Rise.totalDeaths++;\r\n                    canUpdateDeaths = false;\r\n                }\r\n            } else\r\n                canUpdateDeaths = true;\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    if (module instanceof Fly)\r\n                        Rise.distanceFlew += d;\r\n\r\n                    Rise.amountOfModulesOn++;\r\n\r\n                    module.onPostMotion(event);\r\n                }\r\n            }\r\n        } else if (e instanceof PreMotionEvent) {\r\n            final PreMotionEvent event = ((PreMotionEvent) e);\r\n\r\n            /* Used to reset PlayerUtil.isOnServer() */\r\n            if (mc.thePlayer.ticksExisted == 1) {\r\n                PlayerUtil.serverResponses.clear();\r\n                PlayerUtil.sentEmail = false;\r\n            }\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onPreMotion(event);\r\n                }\r\n\r\n                /* Calls events that are always used called whether the module is on or not*/\r\n                if (mc.currentScreen instanceof ClickGUI || mc.currentScreen instanceof StrikeGUI) {\r\n                    module.onUpdateAlwaysInGui();\r\n                }\r\n                module.onUpdateAlways();\r\n            }\r\n        } else if (e instanceof KeyEvent) {\r\n            final KeyEvent event = ((KeyEvent) e);\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onKey(event);\r\n                }\r\n\r\n                if (module.getKeyBind() == event.getKey() && (!module.getModuleInfo().name().equals(\"Freelook\") || !module.isEnabled())) {\r\n                    module.toggleModule();\r\n                }\r\n            }\r\n        } else if (e instanceof StrafeEvent) {\r\n            final StrafeEvent event = ((StrafeEvent) e);\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onStrafe(event);\r\n                }\r\n            }\r\n        } else if (e instanceof CanPlaceBlockEvent) {\r\n            final CanPlaceBlockEvent event = ((CanPlaceBlockEvent) e);\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onCanPlaceBlockEvent(event);\r\n                }\r\n            }\r\n        } else if (e instanceof BlockBreakEvent) {\r\n            final BlockBreakEvent event = ((BlockBreakEvent) e);\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onBlockBreak(event);\r\n                }\r\n            }\r\n        } else if (e instanceof AttackEvent) {\r\n            final AttackEvent event = ((AttackEvent) e);\r\n\r\n            //Statistics\r\n            final Entity entity = event.getTarget();\r\n            if (entity instanceof EntityPlayer) {\r\n                target = (EntityPlayer) entity;\r\n            }\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onAttackEvent(event);\r\n                }\r\n            }\r\n        } else if (e instanceof MoveButtonEvent) {\r\n            final MoveButtonEvent event = ((MoveButtonEvent) e);\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onMoveButton(event);\r\n                }\r\n            }\r\n        } else if (e instanceof MoveEvent) {\r\n            final MoveEvent event = ((MoveEvent) e);\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onMove(event);\r\n                }\r\n            }\r\n        } else if (e instanceof WorldChangedEvent) {\r\n            final WorldChangedEvent event = ((WorldChangedEvent) e);\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onWorldChanged(event);\r\n                }\r\n            }\r\n        } else if (e instanceof UpdateEvent) {\r\n            final UpdateEvent event = ((UpdateEvent) e);\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onUpdate(event);\r\n                }\r\n            }\r\n        } else if (e instanceof BlockCollideEvent) {\r\n            final BlockCollideEvent event = ((BlockCollideEvent) e);\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onBlockCollide(event);\r\n                }\r\n            }\r\n        } else if (e instanceof TeleportEvent) {\r\n            final TeleportEvent event = ((TeleportEvent) e);\r\n\r\n            for (final Module module : modules) {\r\n                if (module.isEnabled()) {\r\n                    module.onTeleportEvent(event);\r\n                }\r\n            }\r\n        }\r\n\r\n        final int r = Interface.red0;\r\n        final int g = Interface.green0;\r\n        final int b = Interface.blue0;\r\n\r\n        final Color bright = new Color(Math.min(r + 26, 255), Math.min(g + 45, 255), Math.min(b + 13, 255));\r\n\r\n        Rise.CLIENT_THEME_COLOR = new Color(r, g, b, 255).getRGB();\r\n        Rise.CLIENT_THEME_COLOR_BRIGHT = bright.hashCode();\r\n        Rise.CLIENT_THEME_COLOR_BRIGHT_COLOR = bright;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/dev/risas/event/EventHandler.java b/dev/risas/event/EventHandler.java
--- a/dev/risas/event/EventHandler.java	(revision 12f741f73fd2ba762ae96403a891020f2d06a691)
+++ b/dev/risas/event/EventHandler.java	(date 1727748880989)
@@ -13,7 +13,6 @@
 import dev.risas.module.Module;
 import dev.risas.module.impl.movement.Fly;
 import dev.risas.module.impl.other.AntiCheat;
-import dev.risas.module.impl.other.Disabler;
 import dev.risas.module.impl.render.Interface;
 import dev.risas.ui.clickgui.impl.ClickGUI;
 import dev.risas.ui.clickgui.impl.strikeless.StrikeGUI;
Index: net/minecraft/entity/Entity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package net.minecraft.entity;\r\n\r\nimport dev.risas.Rise;\r\nimport dev.risas.event.impl.other.StrafeEvent;\r\nimport dev.risas.module.impl.movement.Step;\r\nimport dev.risas.setting.impl.BooleanSetting;\r\nimport net.minecraft.block.*;\r\nimport net.minecraft.block.material.Material;\r\nimport net.minecraft.block.state.IBlockState;\r\nimport net.minecraft.block.state.pattern.BlockPattern;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.command.CommandResultStats;\r\nimport net.minecraft.command.ICommandSender;\r\nimport net.minecraft.crash.CrashReport;\r\nimport net.minecraft.crash.CrashReportCategory;\r\nimport net.minecraft.enchantment.EnchantmentHelper;\r\nimport net.minecraft.enchantment.EnchantmentProtection;\r\nimport net.minecraft.entity.effect.EntityLightningBolt;\r\nimport net.minecraft.entity.item.EntityItem;\r\nimport net.minecraft.entity.player.EntityPlayer;\r\nimport net.minecraft.entity.player.EntityPlayerMP;\r\nimport net.minecraft.event.HoverEvent;\r\nimport net.minecraft.init.Blocks;\r\nimport net.minecraft.item.Item;\r\nimport net.minecraft.item.ItemStack;\r\nimport net.minecraft.nbt.NBTTagCompound;\r\nimport net.minecraft.nbt.NBTTagDouble;\r\nimport net.minecraft.nbt.NBTTagFloat;\r\nimport net.minecraft.nbt.NBTTagList;\r\nimport net.minecraft.server.MinecraftServer;\r\nimport net.minecraft.util.*;\r\nimport net.minecraft.world.Explosion;\r\nimport net.minecraft.world.World;\r\nimport net.minecraft.world.WorldServer;\r\n\r\nimport java.util.List;\r\nimport java.util.Objects;\r\nimport java.util.Random;\r\nimport java.util.UUID;\r\n\r\npublic abstract class Entity implements ICommandSender {\r\n    private static final AxisAlignedBB ZERO_AABB = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D);\r\n    private static int nextEntityID;\r\n    private int entityId;\r\n    public double renderDistanceWeight;\r\n\r\n    /**\r\n     * Blocks entities from spawning when they do their AABB check to make sure the spot is clear of entities that can\r\n     * prevent spawning.\r\n     */\r\n    public boolean preventEntitySpawning;\r\n\r\n    /**\r\n     * The entity that is riding this entity\r\n     */\r\n    public Entity riddenByEntity;\r\n\r\n    /**\r\n     * The entity we are currently riding\r\n     */\r\n    public Entity ridingEntity;\r\n    public boolean forceSpawn;\r\n\r\n    /**\r\n     * Reference to the World object.\r\n     */\r\n    public World worldObj;\r\n    public double prevPosX;\r\n    public double prevPosY;\r\n    public double prevPosZ;\r\n\r\n    /**\r\n     * Entity position X\r\n     */\r\n    public double posX;\r\n\r\n    /**\r\n     * Entity position Y\r\n     */\r\n    public double posY;\r\n\r\n    /**\r\n     * Entity position Z\r\n     */\r\n    public double posZ;\r\n\r\n    /**\r\n     * Entity motion X\r\n     */\r\n    public double motionX;\r\n\r\n    /**\r\n     * Entity motion Y\r\n     */\r\n    public double motionY;\r\n\r\n    /**\r\n     * Entity motion Z\r\n     */\r\n    public double motionZ;\r\n\r\n    /**\r\n     * Entity rotation Yaw\r\n     */\r\n    public float rotationYaw;\r\n\r\n    /**\r\n     * Entity rotation Pitch\r\n     */\r\n    public float rotationPitch;\r\n    public float prevRotationYaw;\r\n    public float prevRotationPitch;\r\n\r\n    // GAY\r\n    public boolean flagSex = false;\r\n\r\n    /**\r\n     * Axis aligned bounding box.\r\n     */\r\n    public AxisAlignedBB boundingBox;\r\n    public boolean onGround;\r\n\r\n    /**\r\n     * True if after a move this entity has collided with something on X- or Z-axis\r\n     */\r\n    public boolean isCollidedHorizontally;\r\n\r\n    /**\r\n     * True if after a move this entity has collided with something on Y-axis\r\n     */\r\n    public boolean isCollidedVertically;\r\n\r\n    /**\r\n     * True if after a move this entity has collided with something either vertically or horizontally\r\n     */\r\n    public boolean isCollided;\r\n    public boolean velocityChanged;\r\n    protected boolean isInWeb;\r\n    private boolean isOutsideBorder;\r\n\r\n    /**\r\n     * gets set by setEntityDead, so this must be the flag whether an Entity is dead (inactive may be better term)\r\n     */\r\n    public boolean isDead;\r\n\r\n    /**\r\n     * How wide this entity is considered to be\r\n     */\r\n    public float width;\r\n\r\n    /**\r\n     * How high this entity is considered to be\r\n     */\r\n    public float height;\r\n\r\n    /**\r\n     * The previous ticks distance walked multiplied by 0.6\r\n     */\r\n    public float prevDistanceWalkedModified;\r\n\r\n    /**\r\n     * The distance walked multiplied by 0.6\r\n     */\r\n    public float distanceWalkedModified;\r\n    public float distanceWalkedOnStepModified;\r\n    public float fallDistance;\r\n\r\n    /**\r\n     * The distance that has to be exceeded in order to triger a new step sound and an onEntityWalking event on a block\r\n     */\r\n    private int nextStepDistance;\r\n\r\n    /**\r\n     * The entity's X coordinate at the previous tick, used to calculate position during rendering routines\r\n     */\r\n    public double lastTickPosX;\r\n\r\n    /**\r\n     * The entity's Y coordinate at the previous tick, used to calculate position during rendering routines\r\n     */\r\n    public double lastTickPosY;\r\n\r\n    /**\r\n     * The entity's Z coordinate at the previous tick, used to calculate position during rendering routines\r\n     */\r\n    public double lastTickPosZ;\r\n\r\n    /**\r\n     * How high this entity can step up when running into a block to try to get over it (currently make note the entity\r\n     * will always step up this amount and not just the amount needed)\r\n     */\r\n    public float stepHeight;\r\n\r\n    /**\r\n     * Whether this entity won't clip with collision or not (make note it won't disable gravity)\r\n     */\r\n    public boolean noClip;\r\n\r\n    /**\r\n     * Reduces the velocity applied by entity collisions by the specified percent.\r\n     */\r\n    public float entityCollisionReduction;\r\n    protected Random rand;\r\n\r\n    /**\r\n     * How many ticks has this entity had ran since being alive\r\n     */\r\n    public int ticksExisted;\r\n\r\n    /**\r\n     * The amount of ticks you have to stand inside of fire before be set on fire\r\n     */\r\n    public int fireResistance;\r\n    public int fire;\r\n\r\n    /**\r\n     * Whether this entity is currently inside of water (if it handles water movement that is)\r\n     */\r\n    protected boolean inWater;\r\n\r\n    /**\r\n     * Remaining time an entity will be \"immune\" to further damage after being hurt.\r\n     */\r\n    public int hurtResistantTime;\r\n    protected boolean firstUpdate;\r\n    protected boolean isImmuneToFire;\r\n    protected DataWatcher dataWatcher;\r\n    private double entityRiderPitchDelta;\r\n    private double entityRiderYawDelta;\r\n\r\n    /**\r\n     * Has this entity been added to the chunk its within\r\n     */\r\n    public boolean addedToChunk;\r\n    public int chunkCoordX;\r\n    public int chunkCoordY;\r\n    public int chunkCoordZ;\r\n    public int serverPosX;\r\n    public int serverPosY;\r\n    public int serverPosZ;\r\n\r\n    /**\r\n     * Render entity even if it is outside the camera frustum. Only true in EntityFish for now. Used in RenderGlobal:\r\n     * render if ignoreFrustumCheck or in frustum.\r\n     */\r\n    public boolean ignoreFrustumCheck;\r\n    public boolean isAirBorne;\r\n    public int timeUntilPortal;\r\n\r\n    /**\r\n     * Whether the entity is inside a Portal\r\n     */\r\n    protected boolean inPortal;\r\n    protected int portalCounter;\r\n\r\n    /**\r\n     * Which dimension the player is in (-1 = the Nether, 0 = normal world)\r\n     */\r\n    public int dimension;\r\n    protected BlockPos field_181016_an;\r\n    protected Vec3 field_181017_ao;\r\n    protected EnumFacing field_181018_ap;\r\n    private boolean invulnerable;\r\n    protected UUID entityUniqueID;\r\n\r\n    public boolean bot;\r\n\r\n    /**\r\n     * The command result statistics for this Entity.\r\n     */\r\n    private final CommandResultStats cmdResultStats;\r\n\r\n    public int getEntityId() {\r\n        return this.entityId;\r\n    }\r\n\r\n    public void setEntityId(final int id) {\r\n        this.entityId = id;\r\n    }\r\n\r\n    /**\r\n     * Called by the /kill command.\r\n     */\r\n    public void onKillCommand() {\r\n        this.setDead();\r\n    }\r\n\r\n    public Entity(final World worldIn) {\r\n        this.entityId = nextEntityID++;\r\n        this.renderDistanceWeight = 1.0D;\r\n        this.boundingBox = ZERO_AABB;\r\n        this.width = 0.6F;\r\n        this.height = 1.8F;\r\n        this.nextStepDistance = 1;\r\n        this.rand = new Random();\r\n        this.fireResistance = 1;\r\n        this.firstUpdate = true;\r\n        this.entityUniqueID = MathHelper.getRandomUuid(this.rand);\r\n        this.cmdResultStats = new CommandResultStats();\r\n        this.worldObj = worldIn;\r\n        this.setPosition(0.0D, 0.0D, 0.0D);\r\n\r\n        if (worldIn != null) {\r\n            this.dimension = worldIn.provider.getDimensionId();\r\n        }\r\n\r\n        this.dataWatcher = new DataWatcher(this);\r\n        this.dataWatcher.addObject(0, (byte) 0);\r\n        this.dataWatcher.addObject(1, (short) 300);\r\n        this.dataWatcher.addObject(3, (byte) 0);\r\n        this.dataWatcher.addObject(2, \"\");\r\n        this.dataWatcher.addObject(4, (byte) 0);\r\n        this.entityInit();\r\n    }\r\n\r\n    protected abstract void entityInit();\r\n\r\n    public DataWatcher getDataWatcher() {\r\n        return this.dataWatcher;\r\n    }\r\n\r\n    public boolean equals(final Object p_equals_1_) {\r\n        return p_equals_1_ instanceof Entity && ((Entity) p_equals_1_).entityId == this.entityId;\r\n    }\r\n\r\n    public int hashCode() {\r\n        return this.entityId;\r\n    }\r\n\r\n    /**\r\n     * Keeps moving the entity up so it isn't colliding with blocks and other requirements for this entity to be spawned\r\n     * (only actually used on players though its also on Entity)\r\n     */\r\n    protected void preparePlayerToSpawn() {\r\n        if (this.worldObj != null) {\r\n            while (this.posY > 0.0D && this.posY < 256.0D) {\r\n                this.setPosition(this.posX, this.posY, this.posZ);\r\n\r\n                if (this.worldObj.getCollidingBoundingBoxes(this, this.getEntityBoundingBox()).isEmpty()) {\r\n                    break;\r\n                }\r\n\r\n                ++this.posY;\r\n            }\r\n\r\n            this.motionX = this.motionY = this.motionZ = 0.0D;\r\n            this.rotationPitch = 0.0F;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Will get destroyed next tick.\r\n     */\r\n    public void setDead() {\r\n        this.isDead = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the width and height of the entity. Args: width, height\r\n     */\r\n    protected void setSize(final float width, final float height) {\r\n        if (width != this.width || height != this.height) {\r\n            final float f = this.width;\r\n            this.width = width;\r\n            this.height = height;\r\n            this.setEntityBoundingBox(new AxisAlignedBB(this.getEntityBoundingBox().minX, this.getEntityBoundingBox().minY, this.getEntityBoundingBox().minZ, this.getEntityBoundingBox().minX + (double) this.width, this.getEntityBoundingBox().minY + (double) this.height, this.getEntityBoundingBox().minZ + (double) this.width));\r\n\r\n            if (this.width > f && !this.firstUpdate && !this.worldObj.isRemote) {\r\n                this.moveEntity(f - this.width, 0.0D, f - this.width);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the rotation of the entity. Args: yaw, pitch (both in degrees)\r\n     */\r\n    protected void setRotation(final float yaw, final float pitch) {\r\n        this.rotationYaw = yaw % 360.0F;\r\n        this.rotationPitch = pitch % 360.0F;\r\n    }\r\n\r\n    /**\r\n     * Sets the x,y,z of the entity from the given parameters. Also seems to set up a bounding box.\r\n     */\r\n    public void setPosition(final double x, final double y, final double z) {\r\n        this.posX = x;\r\n        this.posY = y;\r\n        this.posZ = z;\r\n        final float f = this.width / 2.0F;\r\n        final float f1 = this.height;\r\n        this.setEntityBoundingBox(new AxisAlignedBB(x - (double) f, y, z - (double) f, x + (double) f, y + (double) f1, z + (double) f));\r\n    }\r\n\r\n    /**\r\n     * Adds 15% to the entity's yaw and subtracts 15% from the pitch. Clamps pitch from -90 to 90. Both arguments in\r\n     * degrees.\r\n     */\r\n    public void setAngles(final float yaw, final float pitch) {\r\n        final float f = this.rotationPitch;\r\n        final float f1 = this.rotationYaw;\r\n        this.rotationYaw = (float) ((double) this.rotationYaw + (double) yaw * 0.15D);\r\n        this.rotationPitch = (float) ((double) this.rotationPitch - (double) pitch * 0.15D);\r\n        this.rotationPitch = MathHelper.clamp_float(this.rotationPitch, -90.0F, 90.0F);\r\n        this.prevRotationPitch += this.rotationPitch - f;\r\n        this.prevRotationYaw += this.rotationYaw - f1;\r\n    }\r\n\r\n    /**\r\n     * Called to update the entity's position/logic.\r\n     */\r\n    public void onUpdate() {\r\n        this.onEntityUpdate();\r\n    }\r\n\r\n    /**\r\n     * Gets called every tick from main Entity class\r\n     */\r\n    public void onEntityUpdate() {\r\n        this.worldObj.theProfiler.startSection(\"entityBaseTick\");\r\n\r\n        if (this.ridingEntity != null && this.ridingEntity.isDead) {\r\n            this.ridingEntity = null;\r\n        }\r\n\r\n        this.prevDistanceWalkedModified = this.distanceWalkedModified;\r\n        this.prevPosX = this.posX;\r\n        this.prevPosY = this.posY;\r\n        this.prevPosZ = this.posZ;\r\n        this.prevRotationPitch = this.rotationPitch;\r\n        this.prevRotationYaw = this.rotationYaw;\r\n\r\n        if (!this.worldObj.isRemote && this.worldObj instanceof WorldServer) {\r\n            this.worldObj.theProfiler.startSection(\"portal\");\r\n            final MinecraftServer minecraftserver = ((WorldServer) this.worldObj).getMinecraftServer();\r\n            final int i = this.getMaxInPortalTime();\r\n\r\n            if (this.inPortal) {\r\n                if (minecraftserver.getAllowNether()) {\r\n                    if (this.ridingEntity == null && this.portalCounter++ >= i) {\r\n                        this.portalCounter = i;\r\n                        this.timeUntilPortal = this.getPortalCooldown();\r\n                        final int j;\r\n\r\n                        if (this.worldObj.provider.getDimensionId() == -1) {\r\n                            j = 0;\r\n                        } else {\r\n                            j = -1;\r\n                        }\r\n\r\n                        this.travelToDimension(j);\r\n                    }\r\n\r\n                    this.inPortal = false;\r\n                }\r\n            } else {\r\n                if (this.portalCounter > 0) {\r\n                    this.portalCounter -= 4;\r\n                }\r\n\r\n                if (this.portalCounter < 0) {\r\n                    this.portalCounter = 0;\r\n                }\r\n            }\r\n\r\n            if (this.timeUntilPortal > 0) {\r\n                --this.timeUntilPortal;\r\n            }\r\n\r\n            this.worldObj.theProfiler.endSection();\r\n        }\r\n\r\n        this.spawnRunningParticles();\r\n        this.handleWaterMovement();\r\n\r\n        if (this.worldObj.isRemote) {\r\n            this.fire = 0;\r\n        } else if (this.fire > 0) {\r\n            if (this.isImmuneToFire) {\r\n                this.fire -= 4;\r\n\r\n                if (this.fire < 0) {\r\n                    this.fire = 0;\r\n                }\r\n            } else {\r\n                if (this.fire % 20 == 0) {\r\n                    this.attackEntityFrom(DamageSource.onFire, 1.0F);\r\n                }\r\n\r\n                --this.fire;\r\n            }\r\n        }\r\n\r\n        if (this.isInLava()) {\r\n            this.setOnFireFromLava();\r\n            this.fallDistance *= 0.5F;\r\n        }\r\n\r\n        if (this.posY < -64.0D) {\r\n            this.kill();\r\n        }\r\n\r\n        if (!this.worldObj.isRemote) {\r\n            this.setFlag(0, this.fire > 0);\r\n        }\r\n\r\n        this.firstUpdate = false;\r\n        this.worldObj.theProfiler.endSection();\r\n    }\r\n\r\n    /**\r\n     * Return the amount of time this entity should stay in a portal before being transported.\r\n     */\r\n    public int getMaxInPortalTime() {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Called whenever the entity is walking inside of lava.\r\n     */\r\n    protected void setOnFireFromLava() {\r\n        if (!this.isImmuneToFire) {\r\n            this.attackEntityFrom(DamageSource.lava, 4.0F);\r\n            this.setFire(15);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets entity to burn for x amount of seconds, cannot lower amount of existing fire.\r\n     */\r\n    public void setFire(final int seconds) {\r\n        int i = seconds * 20;\r\n        i = EnchantmentProtection.getFireTimeForEntity(this, i);\r\n\r\n        if (this.fire < i) {\r\n            this.fire = i;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes fire from entity.\r\n     */\r\n    public void extinguish() {\r\n        this.fire = 0;\r\n    }\r\n\r\n    /**\r\n     * sets the dead flag. Used when you fall off the bottom of the world.\r\n     */\r\n    protected void kill() {\r\n        this.setDead();\r\n    }\r\n\r\n    /**\r\n     * Checks if the offset position from the entity's current position is inside of liquid. Args: x, y, z\r\n     */\r\n    public boolean isOffsetPositionInLiquid(final double x, final double y, final double z) {\r\n        final AxisAlignedBB axisalignedbb = this.getEntityBoundingBox().offset(x, y, z);\r\n        return this.isLiquidPresentInAABB(axisalignedbb);\r\n    }\r\n\r\n    /**\r\n     * Determines if a liquid is present within the specified AxisAlignedBB.\r\n     */\r\n    private boolean isLiquidPresentInAABB(final AxisAlignedBB bb) {\r\n        return this.worldObj.getCollidingBoundingBoxes(this, bb).isEmpty() && !this.worldObj.isAnyLiquid(bb);\r\n    }\r\n\r\n    /**\r\n     * Tries to moves the entity by the passed in displacement. Args: x, y, z\r\n     */\r\n    public void moveEntity(double x, double y, double z) {\r\n        if (this.noClip) {\r\n            this.setEntityBoundingBox(this.getEntityBoundingBox().offset(x, y, z));\r\n            this.resetPositionToBB();\r\n        } else {\r\n            this.worldObj.theProfiler.startSection(\"move\");\r\n            final double d0 = this.posX;\r\n            final double d1 = this.posY;\r\n            final double d2 = this.posZ;\r\n\r\n            if (this.isInWeb) {\r\n                this.isInWeb = false;\r\n                x *= 0.25D;\r\n                y *= 0.05000000074505806D;\r\n                z *= 0.25D;\r\n                this.motionX = 0.0D;\r\n                this.motionY = 0.0D;\r\n                this.motionZ = 0.0D;\r\n            }\r\n\r\n            double d3 = x;\r\n            final double d4 = y;\r\n            double d5 = z;\r\n            final boolean flag = this.onGround && this.isSneaking() && this instanceof EntityPlayer;\r\n\r\n            flagSex = false;\r\n\r\n            if (Minecraft.getMinecraft().thePlayer != null) {\r\n                try {\r\n                    if ((Objects.requireNonNull(Rise.INSTANCE.getModuleManager().getModule(\"Scaffold\")).isEnabled()\r\n                            && (Objects.requireNonNull((BooleanSetting) Rise.INSTANCE.getModuleManager().getSetting(\"Scaffold\", \"Safe Walk\"))).isEnabled()\r\n                            && !Minecraft.getMinecraft().gameSettings.keyBindSneak.isKeyDown()\r\n                            && Minecraft.getMinecraft().thePlayer.fallDistance < 2)) {\r\n                        flagSex = true;\r\n                    }\r\n                } catch (final Exception ex) {\r\n                    flagSex = false;\r\n                }\r\n            }\r\n\r\n            if (flag || flagSex) {\r\n                final double d6;\r\n\r\n                for (d6 = 0.05D; x != 0.0D && this.worldObj.getCollidingBoundingBoxes(this, this.getEntityBoundingBox().offset(x, -1.0D, 0.0D)).isEmpty(); d3 = x) {\r\n                    if (x < d6 && x >= -d6) {\r\n                        x = 0.0D;\r\n                    } else if (x > 0.0D) {\r\n                        x -= d6;\r\n                    } else {\r\n                        x += d6;\r\n                    }\r\n                }\r\n\r\n                for (; z != 0.0D && this.worldObj.getCollidingBoundingBoxes(this, this.getEntityBoundingBox().offset(0.0D, -1.0D, z)).isEmpty(); d5 = z) {\r\n                    if (z < d6 && z >= -d6) {\r\n                        z = 0.0D;\r\n                    } else if (z > 0.0D) {\r\n                        z -= d6;\r\n                    } else {\r\n                        z += d6;\r\n                    }\r\n                }\r\n\r\n                for (; x != 0.0D && z != 0.0D && this.worldObj.getCollidingBoundingBoxes(this, this.getEntityBoundingBox().offset(x, -1.0D, z)).isEmpty(); d5 = z) {\r\n                    if (x < d6 && x >= -d6) {\r\n                        x = 0.0D;\r\n                    } else if (x > 0.0D) {\r\n                        x -= d6;\r\n                    } else {\r\n                        x += d6;\r\n                    }\r\n\r\n                    d3 = x;\r\n\r\n                    if (z < d6 && z >= -d6) {\r\n                        z = 0.0D;\r\n                    } else if (z > 0.0D) {\r\n                        z -= d6;\r\n                    } else {\r\n                        z += d6;\r\n                    }\r\n                }\r\n            }\r\n\r\n            final List<AxisAlignedBB> list1 = this.worldObj.getCollidingBoundingBoxes(this, this.getEntityBoundingBox().addCoord(x, y, z));\r\n            final AxisAlignedBB axisalignedbb = this.getEntityBoundingBox();\r\n\r\n            for (final AxisAlignedBB axisalignedbb1 : list1) {\r\n                y = axisalignedbb1.calculateYOffset(this.getEntityBoundingBox(), y);\r\n            }\r\n\r\n            this.setEntityBoundingBox(this.getEntityBoundingBox().offset(0.0D, y, 0.0D));\r\n            final boolean flag1 = this.onGround || d4 != y && d4 < 0.0D;\r\n\r\n            for (final AxisAlignedBB axisalignedbb2 : list1) {\r\n                x = axisalignedbb2.calculateXOffset(this.getEntityBoundingBox(), x);\r\n            }\r\n\r\n            this.setEntityBoundingBox(this.getEntityBoundingBox().offset(x, 0.0D, 0.0D));\r\n\r\n            for (final AxisAlignedBB axisalignedbb13 : list1) {\r\n                z = axisalignedbb13.calculateZOffset(this.getEntityBoundingBox(), z);\r\n            }\r\n\r\n            this.setEntityBoundingBox(this.getEntityBoundingBox().offset(0.0D, 0.0D, z));\r\n\r\n            if (this.stepHeight > 0.0F && flag1 && (d3 != x || d5 != z)) {\r\n\r\n                final double d11 = x;\r\n                final double d7 = y;\r\n                final double d8 = z;\r\n                final AxisAlignedBB axisalignedbb3 = this.getEntityBoundingBox();\r\n                this.setEntityBoundingBox(axisalignedbb);\r\n                y = this.stepHeight;\r\n                final List<AxisAlignedBB> list = this.worldObj.getCollidingBoundingBoxes(this, this.getEntityBoundingBox().addCoord(d3, y, d5));\r\n                AxisAlignedBB axisalignedbb4 = this.getEntityBoundingBox();\r\n                final AxisAlignedBB axisalignedbb5 = axisalignedbb4.addCoord(d3, 0.0D, d5);\r\n                double d9 = y;\r\n\r\n                for (final AxisAlignedBB axisalignedbb6 : list) {\r\n                    d9 = axisalignedbb6.calculateYOffset(axisalignedbb5, d9);\r\n                }\r\n\r\n                axisalignedbb4 = axisalignedbb4.offset(0.0D, d9, 0.0D);\r\n                double d15 = d3;\r\n\r\n                for (final AxisAlignedBB axisalignedbb7 : list) {\r\n                    d15 = axisalignedbb7.calculateXOffset(axisalignedbb4, d15);\r\n                }\r\n\r\n                axisalignedbb4 = axisalignedbb4.offset(d15, 0.0D, 0.0D);\r\n                double d16 = d5;\r\n\r\n                for (final AxisAlignedBB axisalignedbb8 : list) {\r\n                    d16 = axisalignedbb8.calculateZOffset(axisalignedbb4, d16);\r\n                }\r\n\r\n                axisalignedbb4 = axisalignedbb4.offset(0.0D, 0.0D, d16);\r\n                AxisAlignedBB axisalignedbb14 = this.getEntityBoundingBox();\r\n                double d17 = y;\r\n\r\n                for (final AxisAlignedBB axisalignedbb9 : list) {\r\n                    d17 = axisalignedbb9.calculateYOffset(axisalignedbb14, d17);\r\n                }\r\n\r\n                axisalignedbb14 = axisalignedbb14.offset(0.0D, d17, 0.0D);\r\n                double d18 = d3;\r\n\r\n                for (final AxisAlignedBB axisalignedbb10 : list) {\r\n                    d18 = axisalignedbb10.calculateXOffset(axisalignedbb14, d18);\r\n                }\r\n\r\n                axisalignedbb14 = axisalignedbb14.offset(d18, 0.0D, 0.0D);\r\n                double d19 = d5;\r\n\r\n                for (final AxisAlignedBB axisalignedbb11 : list) {\r\n                    d19 = axisalignedbb11.calculateZOffset(axisalignedbb14, d19);\r\n                }\r\n\r\n                axisalignedbb14 = axisalignedbb14.offset(0.0D, 0.0D, d19);\r\n                final double d20 = d15 * d15 + d16 * d16;\r\n                final double d10 = d18 * d18 + d19 * d19;\r\n\r\n                if (d20 > d10) {\r\n                    x = d15;\r\n                    z = d16;\r\n                    y = -d9;\r\n                    this.setEntityBoundingBox(axisalignedbb4);\r\n                } else {\r\n                    x = d18;\r\n                    z = d19;\r\n                    y = -d17;\r\n                    this.setEntityBoundingBox(axisalignedbb14);\r\n                }\r\n\r\n                for (final AxisAlignedBB axisalignedbb12 : list) {\r\n                    y = axisalignedbb12.calculateYOffset(this.getEntityBoundingBox(), y);\r\n                }\r\n\r\n                this.setEntityBoundingBox(this.getEntityBoundingBox().offset(0.0D, y, 0.0D));\r\n\r\n                if (d11 * d11 + d8 * d8 >= x * x + z * z) {\r\n                    x = d11;\r\n                    y = d7;\r\n                    z = d8;\r\n                    this.setEntityBoundingBox(axisalignedbb3);\r\n                }\r\n\r\n                Step.onStep();\r\n            }\r\n\r\n            this.worldObj.theProfiler.endSection();\r\n            this.worldObj.theProfiler.startSection(\"rest\");\r\n            this.resetPositionToBB();\r\n            this.isCollidedHorizontally = d3 != x || d5 != z;\r\n            this.isCollidedVertically = d4 != y;\r\n            this.onGround = this.isCollidedVertically && d4 < 0.0D;\r\n            this.isCollided = this.isCollidedHorizontally || this.isCollidedVertically;\r\n            final int i = MathHelper.floor_double(this.posX);\r\n            final int j = MathHelper.floor_double(this.posY - 0.20000000298023224D);\r\n            final int k = MathHelper.floor_double(this.posZ);\r\n            BlockPos blockpos = new BlockPos(i, j, k);\r\n            Block block1 = this.worldObj.getBlockState(blockpos).getBlock();\r\n\r\n            if (block1.getMaterial() == Material.air) {\r\n                final Block block = this.worldObj.getBlockState(blockpos.down()).getBlock();\r\n\r\n                if (block instanceof BlockFence || block instanceof BlockWall || block instanceof BlockFenceGate) {\r\n                    block1 = block;\r\n                    blockpos = blockpos.down();\r\n                }\r\n            }\r\n\r\n            this.updateFallState(y, this.onGround, block1, blockpos);\r\n\r\n            if (d3 != x) {\r\n                this.motionX = 0.0D;\r\n            }\r\n\r\n            if (d5 != z) {\r\n                this.motionZ = 0.0D;\r\n            }\r\n\r\n            if (d4 != y) {\r\n                block1.onLanded(this.worldObj, this);\r\n            }\r\n\r\n            if (this.canTriggerWalking() && !flag && this.ridingEntity == null) {\r\n                final double d12 = this.posX - d0;\r\n                double d13 = this.posY - d1;\r\n                final double d14 = this.posZ - d2;\r\n\r\n                if (block1 != Blocks.ladder) {\r\n                    d13 = 0.0D;\r\n                }\r\n\r\n                if (this.onGround) {\r\n                    block1.onEntityCollidedWithBlock(this.worldObj, blockpos, this);\r\n                }\r\n\r\n                this.distanceWalkedModified = (float) ((double) this.distanceWalkedModified + (double) MathHelper.sqrt_double(d12 * d12 + d14 * d14) * 0.6D);\r\n                this.distanceWalkedOnStepModified = (float) ((double) this.distanceWalkedOnStepModified + (double) MathHelper.sqrt_double(d12 * d12 + d13 * d13 + d14 * d14) * 0.6D);\r\n\r\n                if (this.distanceWalkedOnStepModified > (float) this.nextStepDistance && block1.getMaterial() != Material.air) {\r\n                    this.nextStepDistance = (int) this.distanceWalkedOnStepModified + 1;\r\n\r\n                    if (this.isInWater()) {\r\n                        float f = MathHelper.sqrt_double(this.motionX * this.motionX * 0.20000000298023224D + this.motionY * this.motionY + this.motionZ * this.motionZ * 0.20000000298023224D) * 0.35F;\r\n\r\n                        if (f > 1.0F) {\r\n                            f = 1.0F;\r\n                        }\r\n\r\n                        this.playSound(this.getSwimSound(), f, 1.0F + (this.rand.nextFloat() - this.rand.nextFloat()) * 0.4F);\r\n                    }\r\n\r\n                    this.playStepSound(blockpos, block1);\r\n                }\r\n            }\r\n\r\n            try {\r\n                this.doBlockCollisions();\r\n            } catch (final Throwable throwable) {\r\n                final CrashReport crashreport = CrashReport.makeCrashReport(throwable, \"Checking entity block collision\");\r\n                final CrashReportCategory crashreportcategory = crashreport.makeCategory(\"Entity being checked for collision\");\r\n                this.addEntityCrashInfo(crashreportcategory);\r\n                throw new ReportedException(crashreport);\r\n            }\r\n\r\n            final boolean flag2 = this.isWet();\r\n\r\n            if (this.worldObj.isFlammableWithin(this.getEntityBoundingBox().contract(0.001D, 0.001D, 0.001D))) {\r\n                this.dealFireDamage(1);\r\n\r\n                if (!flag2) {\r\n                    ++this.fire;\r\n\r\n                    if (this.fire == 0) {\r\n                        this.setFire(8);\r\n                    }\r\n                }\r\n            } else if (this.fire <= 0) {\r\n                this.fire = -this.fireResistance;\r\n            }\r\n\r\n            if (flag2 && this.fire > 0) {\r\n                this.playSound(\"random.fizz\", 0.7F, 1.6F + (this.rand.nextFloat() - this.rand.nextFloat()) * 0.4F);\r\n                this.fire = -this.fireResistance;\r\n            }\r\n\r\n            this.worldObj.theProfiler.endSection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the entity's position to the center (planar) and bottom (vertical) points of its bounding box.\r\n     */\r\n    private void resetPositionToBB() {\r\n        this.posX = (this.getEntityBoundingBox().minX + this.getEntityBoundingBox().maxX) / 2.0D;\r\n        this.posY = this.getEntityBoundingBox().minY;\r\n        this.posZ = (this.getEntityBoundingBox().minZ + this.getEntityBoundingBox().maxZ) / 2.0D;\r\n    }\r\n\r\n    protected String getSwimSound() {\r\n        return \"game.neutral.swim\";\r\n    }\r\n\r\n    protected void doBlockCollisions() {\r\n        final BlockPos blockpos = new BlockPos(this.getEntityBoundingBox().minX + 0.001D, this.getEntityBoundingBox().minY + 0.001D, this.getEntityBoundingBox().minZ + 0.001D);\r\n        final BlockPos blockpos1 = new BlockPos(this.getEntityBoundingBox().maxX - 0.001D, this.getEntityBoundingBox().maxY - 0.001D, this.getEntityBoundingBox().maxZ - 0.001D);\r\n\r\n        if (this.worldObj.isAreaLoaded(blockpos, blockpos1)) {\r\n            for (int i = blockpos.getX(); i <= blockpos1.getX(); ++i) {\r\n                for (int j = blockpos.getY(); j <= blockpos1.getY(); ++j) {\r\n                    for (int k = blockpos.getZ(); k <= blockpos1.getZ(); ++k) {\r\n                        final BlockPos blockpos2 = new BlockPos(i, j, k);\r\n                        final IBlockState iblockstate = this.worldObj.getBlockState(blockpos2);\r\n\r\n                        try {\r\n                            iblockstate.getBlock().onEntityCollidedWithBlock(this.worldObj, blockpos2, iblockstate, this);\r\n                        } catch (final Throwable throwable) {\r\n                            final CrashReport crashreport = CrashReport.makeCrashReport(throwable, \"Colliding entity with block\");\r\n                            final CrashReportCategory crashreportcategory = crashreport.makeCategory(\"Block being collided with\");\r\n                            CrashReportCategory.addBlockInfo(crashreportcategory, blockpos2, iblockstate);\r\n                            throw new ReportedException(crashreport);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected void playStepSound(final BlockPos pos, final Block blockIn) {\r\n        Block.SoundType block$soundtype = blockIn.stepSound;\r\n\r\n        if (this.worldObj.getBlockState(pos.up()).getBlock() == Blocks.snow_layer) {\r\n            block$soundtype = Blocks.snow_layer.stepSound;\r\n            this.playSound(block$soundtype.getStepSound(), block$soundtype.getVolume() * 0.15F, block$soundtype.getFrequency());\r\n        } else if (!blockIn.getMaterial().isLiquid()) {\r\n            this.playSound(block$soundtype.getStepSound(), block$soundtype.getVolume() * 0.15F, block$soundtype.getFrequency());\r\n        }\r\n    }\r\n\r\n    public void playSound(final String name, final float volume, final float pitch) {\r\n        if (!this.isSilent()) {\r\n            this.worldObj.playSoundAtEntity(this, name, volume, pitch);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return True if this entity will not play sounds\r\n     */\r\n    public boolean isSilent() {\r\n        return this.dataWatcher.getWatchableObjectByte(4) == 1;\r\n    }\r\n\r\n    /**\r\n     * When set to true the entity will not play sounds.\r\n     *\r\n     * @param isSilent Should the mob be set to silent?\r\n     */\r\n    public void setSilent(final boolean isSilent) {\r\n        this.dataWatcher.updateObject(4, Byte.valueOf((byte) (isSilent ? 1 : 0)));\r\n    }\r\n\r\n    /**\r\n     * returns if this entity triggers Block.onEntityWalking on the blocks they walk on. used for spiders and wolves to\r\n     * prevent them from trampling crops\r\n     */\r\n    protected boolean canTriggerWalking() {\r\n        return true;\r\n    }\r\n\r\n    protected void updateFallState(final double y, final boolean onGroundIn, final Block blockIn, final BlockPos pos) {\r\n        if (onGroundIn) {\r\n            if (this.fallDistance > 0.0F) {\r\n                if (blockIn != null) {\r\n                    blockIn.onFallenUpon(this.worldObj, pos, this, this.fallDistance);\r\n                } else {\r\n                    this.fall(this.fallDistance, 1.0F);\r\n                }\r\n\r\n                this.fallDistance = 0.0F;\r\n            }\r\n        } else if (y < 0.0D) {\r\n            this.fallDistance = (float) ((double) this.fallDistance - y);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the collision bounding box for this entity\r\n     */\r\n    public AxisAlignedBB getCollisionBoundingBox() {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Will deal the specified amount of damage to the entity if the entity isn't immune to fire damage. Args:\r\n     * amountDamage\r\n     */\r\n    protected void dealFireDamage(final int amount) {\r\n        if (!this.isImmuneToFire) {\r\n            this.attackEntityFrom(DamageSource.inFire, (float) amount);\r\n        }\r\n    }\r\n\r\n    public final boolean isImmuneToFire() {\r\n        return this.isImmuneToFire;\r\n    }\r\n\r\n    public void fall(final float distance, final float damageMultiplier) {\r\n        if (this.riddenByEntity != null) {\r\n            this.riddenByEntity.fall(distance, damageMultiplier);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if this entity is either in water or on an open air block in rain (used in wolves).\r\n     */\r\n    public boolean isWet() {\r\n        return this.inWater || this.worldObj.canLightningStrike(new BlockPos(this.posX, this.posY, this.posZ)) || this.worldObj.canLightningStrike(new BlockPos(this.posX, this.posY + (double) this.height, this.posZ));\r\n    }\r\n\r\n    /**\r\n     * Checks if this entity is inside water (if inWater field is true as a result of handleWaterMovement() returning\r\n     * true)\r\n     */\r\n    public boolean isInWater() {\r\n        return this.inWater;\r\n    }\r\n\r\n    public boolean isInLiquid() {\r\n        return this.isInWater() || this.isInLava();\r\n    }\r\n\r\n    /**\r\n     * Returns if this entity is in water and will end up adding the waters velocity to the entity\r\n     */\r\n    public boolean handleWaterMovement() {\r\n        if (this.worldObj.handleMaterialAcceleration(this.getEntityBoundingBox().expand(0.0D, -0.4000000059604645D, 0.0D).contract(0.001D, 0.001D, 0.001D), Material.water, this)) {\r\n            if (!this.inWater && !this.firstUpdate) {\r\n                this.resetHeight();\r\n            }\r\n\r\n            this.fallDistance = 0.0F;\r\n            this.inWater = true;\r\n            this.fire = 0;\r\n        } else {\r\n            this.inWater = false;\r\n        }\r\n\r\n        return this.inWater;\r\n    }\r\n\r\n    /**\r\n     * sets the players height back to normal after doing things like sleeping and dieing\r\n     */\r\n    protected void resetHeight() {\r\n        float f = MathHelper.sqrt_double(this.motionX * this.motionX * 0.20000000298023224D + this.motionY * this.motionY + this.motionZ * this.motionZ * 0.20000000298023224D) * 0.2F;\r\n\r\n        if (f > 1.0F) {\r\n            f = 1.0F;\r\n        }\r\n\r\n        this.playSound(this.getSplashSound(), f, 1.0F + (this.rand.nextFloat() - this.rand.nextFloat()) * 0.4F);\r\n        final float f1 = (float) MathHelper.floor_double(this.getEntityBoundingBox().minY);\r\n\r\n        for (int i = 0; (float) i < 1.0F + this.width * 20.0F; ++i) {\r\n            final float f2 = (this.rand.nextFloat() * 2.0F - 1.0F) * this.width;\r\n            final float f3 = (this.rand.nextFloat() * 2.0F - 1.0F) * this.width;\r\n            this.worldObj.spawnParticle(EnumParticleTypes.WATER_BUBBLE, this.posX + (double) f2, f1 + 1.0F, this.posZ + (double) f3, this.motionX, this.motionY - (double) (this.rand.nextFloat() * 0.2F), this.motionZ);\r\n        }\r\n\r\n        for (int j = 0; (float) j < 1.0F + this.width * 20.0F; ++j) {\r\n            final float f4 = (this.rand.nextFloat() * 2.0F - 1.0F) * this.width;\r\n            final float f5 = (this.rand.nextFloat() * 2.0F - 1.0F) * this.width;\r\n            this.worldObj.spawnParticle(EnumParticleTypes.WATER_SPLASH, this.posX + (double) f4, f1 + 1.0F, this.posZ + (double) f5, this.motionX, this.motionY, this.motionZ);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attempts to create sprinting particles if the entity is sprinting and not in water.\r\n     */\r\n    public void spawnRunningParticles() {\r\n        if (this.isSprinting() && !this.isInWater()) {\r\n            this.createRunningParticles();\r\n        }\r\n    }\r\n\r\n    protected void createRunningParticles() {\r\n        final int i = MathHelper.floor_double(this.posX);\r\n        final int j = MathHelper.floor_double(this.posY - 0.20000000298023224D);\r\n        final int k = MathHelper.floor_double(this.posZ);\r\n        final BlockPos blockpos = new BlockPos(i, j, k);\r\n        final IBlockState iblockstate = this.worldObj.getBlockState(blockpos);\r\n        final Block block = iblockstate.getBlock();\r\n\r\n        if (block.getRenderType() != -1) {\r\n            this.worldObj.spawnParticle(EnumParticleTypes.BLOCK_CRACK, this.posX + ((double) this.rand.nextFloat() - 0.5D) * (double) this.width, this.getEntityBoundingBox().minY + 0.1D, this.posZ + ((double) this.rand.nextFloat() - 0.5D) * (double) this.width, -this.motionX * 4.0D, 1.5D, -this.motionZ * 4.0D, Block.getStateId(iblockstate));\r\n        }\r\n    }\r\n\r\n    protected String getSplashSound() {\r\n        return \"game.neutral.swim.splash\";\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block the entity is within of the specified material type\r\n     */\r\n    public boolean isInsideOfMaterial(final Material materialIn) {\r\n        final double d0 = this.posY + (double) this.getEyeHeight();\r\n        final BlockPos blockpos = new BlockPos(this.posX, d0, this.posZ);\r\n        final IBlockState iblockstate = this.worldObj.getBlockState(blockpos);\r\n        final Block block = iblockstate.getBlock();\r\n\r\n        if (block.getMaterial() == materialIn) {\r\n            final float f = BlockLiquid.getLiquidHeightPercent(iblockstate.getBlock().getMetaFromState(iblockstate)) - 0.11111111F;\r\n            final float f1 = (float) (blockpos.getY() + 1) - f;\r\n            final boolean flag = d0 < (double) f1;\r\n            return flag;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean isInLava() {\r\n        return this.worldObj.isMaterialInBB(this.getEntityBoundingBox().expand(-0.10000000149011612D, -0.4000000059604645D, -0.10000000149011612D), Material.lava);\r\n    }\r\n\r\n    /**\r\n     * Used in both water and by flying objects\r\n     */\r\n    public void moveFlying(float strafe, float forward, float friction) {\r\n        if (this == Minecraft.getMinecraft().thePlayer) {\r\n            final StrafeEvent strafeEvent = new StrafeEvent(forward, strafe, friction);\r\n            strafeEvent.call();\r\n            strafe = strafeEvent.getStrafe();\r\n            forward = strafeEvent.getForward();\r\n            friction = strafeEvent.getFriction();\r\n            if (strafeEvent.isCancelled()) return;\r\n        }\r\n        float f = strafe * strafe + forward * forward;\r\n\r\n        if (f >= 1.0E-4F) {\r\n            f = MathHelper.sqrt_float(f);\r\n\r\n            if (f < 1.0F) {\r\n                f = 1.0F;\r\n            }\r\n\r\n            f = friction / f;\r\n            strafe = strafe * f;\r\n            forward = forward * f;\r\n\r\n            float f1 = MathHelper.sin(this.rotationYaw * (float) Math.PI / 180.0F);\r\n            float f2 = MathHelper.cos(this.rotationYaw * (float) Math.PI / 180.0F);\r\n\r\n            final Minecraft mc = Minecraft.getMinecraft();\r\n            if (this == mc.thePlayer) {\r\n                if (EntityPlayer.movementYaw != null) {\r\n                    f1 = MathHelper.sin(EntityPlayer.movementYaw * (float) Math.PI / 180.0F);\r\n                    f2 = MathHelper.cos(EntityPlayer.movementYaw * (float) Math.PI / 180.0F);\r\n                }\r\n            }\r\n\r\n            this.motionX += (strafe * f2 - forward * f1);\r\n            this.motionZ += (forward * f2 + strafe * f1);\r\n        }\r\n    }\r\n\r\n    public int getBrightnessForRender(final float partialTicks) {\r\n        final BlockPos blockpos = new BlockPos(this.posX, this.posY + (double) this.getEyeHeight(), this.posZ);\r\n        return this.worldObj.isBlockLoaded(blockpos) ? this.worldObj.getCombinedLight(blockpos, 0) : 0;\r\n    }\r\n\r\n    /**\r\n     * Gets how bright this entity is.\r\n     */\r\n    public float getBrightness(final float partialTicks) {\r\n        final BlockPos blockpos = new BlockPos(this.posX, this.posY + (double) this.getEyeHeight(), this.posZ);\r\n        return this.worldObj.isBlockLoaded(blockpos) ? this.worldObj.getLightBrightness(blockpos) : 0.0F;\r\n    }\r\n\r\n    /**\r\n     * Sets the reference to the World object.\r\n     */\r\n    public void setWorld(final World worldIn) {\r\n        this.worldObj = worldIn;\r\n    }\r\n\r\n    /**\r\n     * Sets the entity's position and rotation.\r\n     */\r\n    public void setPositionAndRotation(final double x, final double y, final double z, final float yaw, final float pitch) {\r\n        this.prevPosX = this.posX = x;\r\n        this.prevPosY = this.posY = y;\r\n        this.prevPosZ = this.posZ = z;\r\n        this.prevRotationYaw = this.rotationYaw = yaw;\r\n        this.prevRotationPitch = this.rotationPitch = pitch;\r\n        final double d0 = this.prevRotationYaw - yaw;\r\n\r\n        if (d0 < -180.0D) {\r\n            this.prevRotationYaw += 360.0F;\r\n        }\r\n\r\n        if (d0 >= 180.0D) {\r\n            this.prevRotationYaw -= 360.0F;\r\n        }\r\n\r\n        this.setPosition(this.posX, this.posY, this.posZ);\r\n        this.setRotation(yaw, pitch);\r\n    }\r\n\r\n    public void moveToBlockPosAndAngles(final BlockPos pos, final float rotationYawIn, final float rotationPitchIn) {\r\n        this.setLocationAndAngles((double) pos.getX() + 0.5D, pos.getY(), (double) pos.getZ() + 0.5D, rotationYawIn, rotationPitchIn);\r\n    }\r\n\r\n    /**\r\n     * Sets the location and Yaw/Pitch of an entity in the world\r\n     */\r\n    public void setLocationAndAngles(final double x, final double y, final double z, final float yaw, final float pitch) {\r\n        this.lastTickPosX = this.prevPosX = this.posX = x;\r\n        this.lastTickPosY = this.prevPosY = this.posY = y;\r\n        this.lastTickPosZ = this.prevPosZ = this.posZ = z;\r\n        this.rotationYaw = yaw;\r\n        this.rotationPitch = pitch;\r\n        this.setPosition(this.posX, this.posY, this.posZ);\r\n    }\r\n\r\n    /**\r\n     * Returns the distance to the entity. Args: entity\r\n     */\r\n    public float getDistanceToEntity(final Entity entityIn) {\r\n        final float f = (float) (this.posX - entityIn.posX);\r\n        final float f1 = (float) (this.posY - entityIn.posY);\r\n        final float f2 = (float) (this.posZ - entityIn.posZ);\r\n        return MathHelper.sqrt_float(f * f + f1 * f1 + f2 * f2);\r\n    }\r\n\r\n    public float getDistanceToEntityRender(final Entity entityIn) {\r\n        final Minecraft mc = Minecraft.getMinecraft();\r\n        final float x = (float) (entityIn.lastTickPosX + (entityIn.posX - entityIn.lastTickPosX) * mc.timer.renderPartialTicks - (mc.getRenderManager()).renderPosX);\r\n        final float y = (float) (entityIn.lastTickPosY + (entityIn.posY - entityIn.lastTickPosY) * mc.timer.renderPartialTicks - (mc.getRenderManager()).renderPosY);\r\n        final float z = (float) (entityIn.lastTickPosZ + (entityIn.posZ - entityIn.lastTickPosZ) * mc.timer.renderPartialTicks - (mc.getRenderManager()).renderPosZ);\r\n\r\n        return MathHelper.sqrt_float(x * x + y * y + z * z);\r\n    }\r\n\r\n    /**\r\n     * Gets the squared distance to the position. Args: x, y, z\r\n     */\r\n    public double getDistanceSq(final double x, final double y, final double z) {\r\n        final double d0 = this.posX - x;\r\n        final double d1 = this.posY - y;\r\n        final double d2 = this.posZ - z;\r\n        return d0 * d0 + d1 * d1 + d2 * d2;\r\n    }\r\n\r\n    public double getDistanceSq(final BlockPos pos) {\r\n        return pos.distanceSq(this.posX, this.posY, this.posZ);\r\n    }\r\n\r\n    public double getDistanceSqToCenter(final BlockPos pos) {\r\n        return pos.distanceSqToCenter(this.posX, this.posY, this.posZ);\r\n    }\r\n\r\n    /**\r\n     * Gets the distance to the position. Args: x, y, z\r\n     */\r\n    public double getDistance(final double x, final double y, final double z) {\r\n        final double d0 = this.posX - x;\r\n        final double d1 = this.posY - y;\r\n        final double d2 = this.posZ - z;\r\n        return MathHelper.sqrt_double(d0 * d0 + d1 * d1 + d2 * d2);\r\n    }\r\n\r\n    /**\r\n     * Returns the squared distance to the entity. Args: entity\r\n     */\r\n    public double getDistanceSqToEntity(final Entity entityIn) {\r\n        if (entityIn == null) return 1D;\r\n        final double d0 = this.posX - entityIn.posX;\r\n        final double d1 = this.posY - entityIn.posY;\r\n        final double d2 = this.posZ - entityIn.posZ;\r\n        return d0 * d0 + d1 * d1 + d2 * d2;\r\n    }\r\n\r\n    /**\r\n     * Called by a player entity when they collide with an entity\r\n     */\r\n    public void onCollideWithPlayer(final EntityPlayer entityIn) {\r\n    }\r\n\r\n    /**\r\n     * Applies a velocity to each of the entities pushing them away from each other. Args: entity\r\n     */\r\n    public void applyEntityCollision(final Entity entityIn) {\r\n        if (entityIn.riddenByEntity != this && entityIn.ridingEntity != this) {\r\n            if (!entityIn.noClip && !this.noClip) {\r\n                double d0 = entityIn.posX - this.posX;\r\n                double d1 = entityIn.posZ - this.posZ;\r\n                double d2 = MathHelper.abs_max(d0, d1);\r\n\r\n                if (d2 >= 0.009999999776482582D) {\r\n                    d2 = MathHelper.sqrt_double(d2);\r\n                    d0 = d0 / d2;\r\n                    d1 = d1 / d2;\r\n                    double d3 = 1.0D / d2;\r\n\r\n                    if (d3 > 1.0D) {\r\n                        d3 = 1.0D;\r\n                    }\r\n\r\n                    d0 = d0 * d3;\r\n                    d1 = d1 * d3;\r\n                    d0 = d0 * 0.05000000074505806D;\r\n                    d1 = d1 * 0.05000000074505806D;\r\n                    d0 = d0 * (double) (1.0F - this.entityCollisionReduction);\r\n                    d1 = d1 * (double) (1.0F - this.entityCollisionReduction);\r\n\r\n                    if (this.riddenByEntity == null) {\r\n                        this.addVelocity(-d0, 0.0D, -d1);\r\n                    }\r\n\r\n                    if (entityIn.riddenByEntity == null) {\r\n                        entityIn.addVelocity(d0, 0.0D, d1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds to the current velocity of the entity. Args: x, y, z\r\n     */\r\n    public void addVelocity(final double x, final double y, final double z) {\r\n        this.motionX += x;\r\n        this.motionY += y;\r\n        this.motionZ += z;\r\n        this.isAirBorne = true;\r\n    }\r\n\r\n    /**\r\n     * Sets that this entity has been attacked.\r\n     */\r\n    protected void setBeenAttacked() {\r\n        this.velocityChanged = true;\r\n    }\r\n\r\n    /**\r\n     * Called when the entity is attacked.\r\n     */\r\n    public boolean attackEntityFrom(final DamageSource source, final float amount) {\r\n        if (!this.isEntityInvulnerable(source)) {\r\n            this.setBeenAttacked();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * interpolated look vector\r\n     */\r\n    public Vec3 getLook(final float partialTicks) {\r\n        if (partialTicks == 1.0F) {\r\n            return this.getVectorForRotation(this.rotationPitch, this.rotationYaw);\r\n        } else {\r\n            final float f = this.prevRotationPitch + (this.rotationPitch - this.prevRotationPitch) * partialTicks;\r\n            final float f1 = this.prevRotationYaw + (this.rotationYaw - this.prevRotationYaw) * partialTicks;\r\n            return this.getVectorForRotation(f, f1);\r\n        }\r\n    }\r\n\r\n    public Vec3 getLookCustom(final float yaw, final float pitch) {\r\n        return this.getVectorForRotation(pitch, yaw);\r\n    }\r\n\r\n    /**\r\n     * Creates a Vec3 using the pitch and yaw of the entities rotation.\r\n     *\r\n     * @param pitch The rotational pitch of the entity.\r\n     * @param yaw   The rotational yaw of the entity.\r\n     */\r\n    public final Vec3 getVectorForRotation(final float pitch, final float yaw) {\r\n        final float f = MathHelper.cos(-yaw * 0.017453292F - (float) Math.PI);\r\n        final float f1 = MathHelper.sin(-yaw * 0.017453292F - (float) Math.PI);\r\n        final float f2 = -MathHelper.cos(-pitch * 0.017453292F);\r\n        final float f3 = MathHelper.sin(-pitch * 0.017453292F);\r\n        return new Vec3(f1 * f2, f3, f * f2);\r\n    }\r\n\r\n    public Vec3 getPositionEyes(final float partialTicks) {\r\n        if (partialTicks == 1.0F) {\r\n            return new Vec3(this.posX, this.posY + (double) this.getEyeHeight(), this.posZ);\r\n        } else {\r\n            final double d0 = this.prevPosX + (this.posX - this.prevPosX) * (double) partialTicks;\r\n            final double d1 = this.prevPosY + (this.posY - this.prevPosY) * (double) partialTicks + (double) this.getEyeHeight();\r\n            final double d2 = this.prevPosZ + (this.posZ - this.prevPosZ) * (double) partialTicks;\r\n            return new Vec3(d0, d1, d2);\r\n        }\r\n    }\r\n\r\n    public MovingObjectPosition rayTrace(final double blockReachDistance, final float partialTicks) {\r\n        final Vec3 vec3 = this.getPositionEyes(partialTicks);\r\n        final Vec3 vec31 = this.getLook(partialTicks);\r\n        final Vec3 vec32 = vec3.addVector(vec31.xCoord * blockReachDistance, vec31.yCoord * blockReachDistance, vec31.zCoord * blockReachDistance);\r\n        return this.worldObj.rayTraceBlocks(vec3, vec32, false, false, true);\r\n    }\r\n\r\n    public MovingObjectPosition rayTraceCustom(final double blockReachDistance, final float yaw, final float pitch) {\r\n        final Vec3 vec3 = this.getPositionEyes(Minecraft.getMinecraft().timer.renderPartialTicks);\r\n        final Vec3 vec31 = this.getLookCustom(yaw, pitch);\r\n        final Vec3 vec32 = vec3.addVector(vec31.xCoord * blockReachDistance, vec31.yCoord * blockReachDistance, vec31.zCoord * blockReachDistance);\r\n        return this.worldObj.rayTraceBlocks(vec3, vec32, false, false, true);\r\n    }\r\n\r\n    public MovingObjectPosition rayTraceCustom(final double blockReachDistance, final float partialTicks, final float yaw, final float pitch) {\r\n        final Vec3 vec3 = this.getPositionEyes(partialTicks);\r\n        final Vec3 vec31 = this.getLookCustom(yaw, pitch);\r\n        final Vec3 vec32 = vec3.addVector(vec31.xCoord * blockReachDistance, vec31.yCoord * blockReachDistance, vec31.zCoord * blockReachDistance);\r\n        return this.worldObj.rayTraceBlocks(vec3, vec32, false, false, true);\r\n    }\r\n\r\n    /**\r\n     * Returns true if other Entities should be prevented from moving through this Entity.\r\n     */\r\n    public boolean canBeCollidedWith() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if this entity should push and be pushed by other entities when colliding.\r\n     */\r\n    public boolean canBePushed() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Adds a value to the player score. Currently not actually used and the entity passed in does nothing. Args:\r\n     * entity, scoreToAdd\r\n     */\r\n    public void addToPlayerScore(final Entity entityIn, final int amount) {\r\n    }\r\n\r\n    public boolean isInRangeToRender3d(final double x, final double y, final double z) {\r\n        final double d0 = this.posX - x;\r\n        final double d1 = this.posY - y;\r\n        final double d2 = this.posZ - z;\r\n        final double d3 = d0 * d0 + d1 * d1 + d2 * d2;\r\n        return this.isInRangeToRenderDist(d3);\r\n    }\r\n\r\n    /**\r\n     * Checks if the entity is in range to render by using the past in distance and comparing it to its average edge\r\n     * length * 64 * renderDistanceWeight Args: distance\r\n     */\r\n    public boolean isInRangeToRenderDist(final double distance) {\r\n        double d0 = this.getEntityBoundingBox().getAverageEdgeLength();\r\n\r\n        if (Double.isNaN(d0)) {\r\n            d0 = 1.0D;\r\n        }\r\n\r\n        d0 = d0 * 64.0D * this.renderDistanceWeight;\r\n        return distance < d0 * d0;\r\n    }\r\n\r\n    /**\r\n     * Like writeToNBTOptional but does not check if the entity is ridden. Used for saving ridden entities with their\r\n     * riders.\r\n     */\r\n    public boolean writeMountToNBT(final NBTTagCompound tagCompund) {\r\n        final String s = this.getEntityString();\r\n\r\n        if (!this.isDead && s != null) {\r\n            tagCompund.setString(\"id\", s);\r\n            this.writeToNBT(tagCompund);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Either write this entity to the NBT tag given and return true, or return false without doing anything. If this\r\n     * returns false the entity is not saved on disk. Ridden entities return false here as they are saved with their\r\n     * rider.\r\n     */\r\n    public boolean writeToNBTOptional(final NBTTagCompound tagCompund) {\r\n        final String s = this.getEntityString();\r\n\r\n        if (!this.isDead && s != null && this.riddenByEntity == null) {\r\n            tagCompund.setString(\"id\", s);\r\n            this.writeToNBT(tagCompund);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Save the entity to NBT (calls an abstract helper method to write extra data)\r\n     */\r\n    public void writeToNBT(final NBTTagCompound tagCompund) {\r\n        try {\r\n            tagCompund.setTag(\"Pos\", this.newDoubleNBTList(this.posX, this.posY, this.posZ));\r\n            tagCompund.setTag(\"Motion\", this.newDoubleNBTList(this.motionX, this.motionY, this.motionZ));\r\n            tagCompund.setTag(\"Rotation\", this.newFloatNBTList(this.rotationYaw, this.rotationPitch));\r\n            tagCompund.setFloat(\"FallDistance\", this.fallDistance);\r\n            tagCompund.setShort(\"Fire\", (short) this.fire);\r\n            tagCompund.setShort(\"Air\", (short) this.getAir());\r\n            tagCompund.setBoolean(\"OnGround\", this.onGround);\r\n            tagCompund.setInteger(\"Dimension\", this.dimension);\r\n            tagCompund.setBoolean(\"Invulnerable\", this.invulnerable);\r\n            tagCompund.setInteger(\"PortalCooldown\", this.timeUntilPortal);\r\n            tagCompund.setLong(\"UUIDMost\", this.getUniqueID().getMostSignificantBits());\r\n            tagCompund.setLong(\"UUIDLeast\", this.getUniqueID().getLeastSignificantBits());\r\n\r\n            if (this.getCustomNameTag() != null && this.getCustomNameTag().length() > 0) {\r\n                tagCompund.setString(\"CustomName\", this.getCustomNameTag());\r\n                tagCompund.setBoolean(\"CustomNameVisible\", this.getAlwaysRenderNameTag());\r\n            }\r\n\r\n            this.cmdResultStats.writeStatsToNBT(tagCompund);\r\n\r\n            if (this.isSilent()) {\r\n                tagCompund.setBoolean(\"Silent\", this.isSilent());\r\n            }\r\n\r\n            this.writeEntityToNBT(tagCompund);\r\n\r\n            if (this.ridingEntity != null) {\r\n                final NBTTagCompound nbttagcompound = new NBTTagCompound();\r\n\r\n                if (this.ridingEntity.writeMountToNBT(nbttagcompound)) {\r\n                    tagCompund.setTag(\"Riding\", nbttagcompound);\r\n                }\r\n            }\r\n        } catch (final Throwable throwable) {\r\n            final CrashReport crashreport = CrashReport.makeCrashReport(throwable, \"Saving entity NBT\");\r\n            final CrashReportCategory crashreportcategory = crashreport.makeCategory(\"Entity being saved\");\r\n            this.addEntityCrashInfo(crashreportcategory);\r\n            throw new ReportedException(crashreport);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reads the entity from NBT (calls an abstract helper method to read specialized data)\r\n     */\r\n    public void readFromNBT(final NBTTagCompound tagCompund) {\r\n        try {\r\n            final NBTTagList nbttaglist = tagCompund.getTagList(\"Pos\", 6);\r\n            final NBTTagList nbttaglist1 = tagCompund.getTagList(\"Motion\", 6);\r\n            final NBTTagList nbttaglist2 = tagCompund.getTagList(\"Rotation\", 5);\r\n            this.motionX = nbttaglist1.getDoubleAt(0);\r\n            this.motionY = nbttaglist1.getDoubleAt(1);\r\n            this.motionZ = nbttaglist1.getDoubleAt(2);\r\n\r\n            if (Math.abs(this.motionX) > 10.0D) {\r\n                this.motionX = 0.0D;\r\n            }\r\n\r\n            if (Math.abs(this.motionY) > 10.0D) {\r\n                this.motionY = 0.0D;\r\n            }\r\n\r\n            if (Math.abs(this.motionZ) > 10.0D) {\r\n                this.motionZ = 0.0D;\r\n            }\r\n\r\n            this.prevPosX = this.lastTickPosX = this.posX = nbttaglist.getDoubleAt(0);\r\n            this.prevPosY = this.lastTickPosY = this.posY = nbttaglist.getDoubleAt(1);\r\n            this.prevPosZ = this.lastTickPosZ = this.posZ = nbttaglist.getDoubleAt(2);\r\n            this.prevRotationYaw = this.rotationYaw = nbttaglist2.getFloatAt(0);\r\n            this.prevRotationPitch = this.rotationPitch = nbttaglist2.getFloatAt(1);\r\n            this.setRotationYawHead(this.rotationYaw);\r\n            this.func_181013_g(this.rotationYaw);\r\n            this.fallDistance = tagCompund.getFloat(\"FallDistance\");\r\n            this.fire = tagCompund.getShort(\"Fire\");\r\n            this.setAir(tagCompund.getShort(\"Air\"));\r\n            this.onGround = tagCompund.getBoolean(\"OnGround\");\r\n            this.dimension = tagCompund.getInteger(\"Dimension\");\r\n            this.invulnerable = tagCompund.getBoolean(\"Invulnerable\");\r\n            this.timeUntilPortal = tagCompund.getInteger(\"PortalCooldown\");\r\n\r\n            if (tagCompund.hasKey(\"UUIDMost\", 4) && tagCompund.hasKey(\"UUIDLeast\", 4)) {\r\n                this.entityUniqueID = new UUID(tagCompund.getLong(\"UUIDMost\"), tagCompund.getLong(\"UUIDLeast\"));\r\n            } else if (tagCompund.hasKey(\"UUID\", 8)) {\r\n                this.entityUniqueID = UUID.fromString(tagCompund.getString(\"UUID\"));\r\n            }\r\n\r\n            this.setPosition(this.posX, this.posY, this.posZ);\r\n            this.setRotation(this.rotationYaw, this.rotationPitch);\r\n\r\n            if (tagCompund.hasKey(\"CustomName\", 8) && tagCompund.getString(\"CustomName\").length() > 0) {\r\n                this.setCustomNameTag(tagCompund.getString(\"CustomName\"));\r\n            }\r\n\r\n            this.setAlwaysRenderNameTag(tagCompund.getBoolean(\"CustomNameVisible\"));\r\n            this.cmdResultStats.readStatsFromNBT(tagCompund);\r\n            this.setSilent(tagCompund.getBoolean(\"Silent\"));\r\n            this.readEntityFromNBT(tagCompund);\r\n\r\n            if (this.shouldSetPosAfterLoading()) {\r\n                this.setPosition(this.posX, this.posY, this.posZ);\r\n            }\r\n        } catch (final Throwable throwable) {\r\n            final CrashReport crashreport = CrashReport.makeCrashReport(throwable, \"Loading entity NBT\");\r\n            final CrashReportCategory crashreportcategory = crashreport.makeCategory(\"Entity being loaded\");\r\n            this.addEntityCrashInfo(crashreportcategory);\r\n            throw new ReportedException(crashreport);\r\n        }\r\n    }\r\n\r\n    protected boolean shouldSetPosAfterLoading() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the string that identifies this Entity's class\r\n     */\r\n    protected final String getEntityString() {\r\n        return EntityList.getEntityString(this);\r\n    }\r\n\r\n    /**\r\n     * (abstract) Protected helper method to read subclass entity data from NBT.\r\n     */\r\n    protected abstract void readEntityFromNBT(NBTTagCompound tagCompund);\r\n\r\n    /**\r\n     * (abstract) Protected helper method to write subclass entity data to NBT.\r\n     */\r\n    protected abstract void writeEntityToNBT(NBTTagCompound tagCompound);\r\n\r\n    public void onChunkLoad() {\r\n    }\r\n\r\n    /**\r\n     * creates a NBT list from the array of doubles passed to this function\r\n     */\r\n    protected NBTTagList newDoubleNBTList(final double... numbers) {\r\n        final NBTTagList nbttaglist = new NBTTagList();\r\n\r\n        for (final double d0 : numbers) {\r\n            nbttaglist.appendTag(new NBTTagDouble(d0));\r\n        }\r\n\r\n        return nbttaglist;\r\n    }\r\n\r\n    /**\r\n     * Returns a new NBTTagList filled with the specified floats\r\n     */\r\n    protected NBTTagList newFloatNBTList(final float... numbers) {\r\n        final NBTTagList nbttaglist = new NBTTagList();\r\n\r\n        for (final float f : numbers) {\r\n            nbttaglist.appendTag(new NBTTagFloat(f));\r\n        }\r\n\r\n        return nbttaglist;\r\n    }\r\n\r\n    public EntityItem dropItem(final Item itemIn, final int size) {\r\n        return this.dropItemWithOffset(itemIn, size, 0.0F);\r\n    }\r\n\r\n    public EntityItem dropItemWithOffset(final Item itemIn, final int size, final float offsetY) {\r\n        return this.entityDropItem(new ItemStack(itemIn, size, 0), offsetY);\r\n    }\r\n\r\n    /**\r\n     * Drops an item at the position of the entity.\r\n     */\r\n    public EntityItem entityDropItem(final ItemStack itemStackIn, final float offsetY) {\r\n        if (itemStackIn.stackSize != 0 && itemStackIn.getItem() != null) {\r\n            final EntityItem entityitem = new EntityItem(this.worldObj, this.posX, this.posY + (double) offsetY, this.posZ, itemStackIn);\r\n            entityitem.setDefaultPickupDelay();\r\n            this.worldObj.spawnEntityInWorld(entityitem);\r\n            return entityitem;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether target entity is alive.\r\n     */\r\n    public boolean isEntityAlive() {\r\n        return !this.isDead;\r\n    }\r\n\r\n    /**\r\n     * Checks if this entity is inside of an opaque block\r\n     */\r\n    public boolean isEntityInsideOpaqueBlock() {\r\n        if (!this.noClip) {\r\n            final BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE);\r\n\r\n            for (int i = 0; i < 8; ++i) {\r\n                final int j = MathHelper.floor_double(this.posY + (double) (((float) ((i >> 0) % 2) - 0.5F) * 0.1F) + (double) this.getEyeHeight());\r\n                final int k = MathHelper.floor_double(this.posX + (double) (((float) ((i >> 1) % 2) - 0.5F) * this.width * 0.8F));\r\n                final int l = MathHelper.floor_double(this.posZ + (double) (((float) ((i >> 2) % 2) - 0.5F) * this.width * 0.8F));\r\n\r\n                if (blockpos$mutableblockpos.getX() != k || blockpos$mutableblockpos.getY() != j || blockpos$mutableblockpos.getZ() != l) {\r\n                    blockpos$mutableblockpos.func_181079_c(k, j, l);\r\n\r\n                    if (this.worldObj.getBlockState(blockpos$mutableblockpos).getBlock().isVisuallyOpaque()) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * First layer of player interaction\r\n     */\r\n    public boolean interactFirst(final EntityPlayer playerIn) {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns a boundingBox used to collide the entity with other entities and blocks. This enables the entity to be\r\n     * pushable on contact, like boats or minecarts.\r\n     */\r\n    public AxisAlignedBB getCollisionBox(final Entity entityIn) {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Handles updating while being ridden by an entity\r\n     */\r\n    public void updateRidden() {\r\n        if (this.ridingEntity.isDead) {\r\n            this.ridingEntity = null;\r\n        } else {\r\n            this.motionX = 0.0D;\r\n            this.motionY = 0.0D;\r\n            this.motionZ = 0.0D;\r\n            this.onUpdate();\r\n\r\n            if (this.ridingEntity != null) {\r\n                this.ridingEntity.updateRiderPosition();\r\n                this.entityRiderYawDelta += this.ridingEntity.rotationYaw - this.ridingEntity.prevRotationYaw;\r\n\r\n                for (this.entityRiderPitchDelta += this.ridingEntity.rotationPitch - this.ridingEntity.prevRotationPitch; this.entityRiderYawDelta >= 180.0D; this.entityRiderYawDelta -= 360.0D) {\r\n                }\r\n\r\n                while (this.entityRiderYawDelta < -180.0D) {\r\n                    this.entityRiderYawDelta += 360.0D;\r\n                }\r\n\r\n                while (this.entityRiderPitchDelta >= 180.0D) {\r\n                    this.entityRiderPitchDelta -= 360.0D;\r\n                }\r\n\r\n                while (this.entityRiderPitchDelta < -180.0D) {\r\n                    this.entityRiderPitchDelta += 360.0D;\r\n                }\r\n\r\n                double d0 = this.entityRiderYawDelta * 0.5D;\r\n                double d1 = this.entityRiderPitchDelta * 0.5D;\r\n                final float f = 10.0F;\r\n\r\n                if (d0 > (double) f) {\r\n                    d0 = f;\r\n                }\r\n\r\n                if (d0 < (double) (-f)) {\r\n                    d0 = -f;\r\n                }\r\n\r\n                if (d1 > (double) f) {\r\n                    d1 = f;\r\n                }\r\n\r\n                if (d1 < (double) (-f)) {\r\n                    d1 = -f;\r\n                }\r\n\r\n                this.entityRiderYawDelta -= d0;\r\n                this.entityRiderPitchDelta -= d1;\r\n            }\r\n        }\r\n    }\r\n\r\n    public void updateRiderPosition() {\r\n        if (this.riddenByEntity != null) {\r\n            this.riddenByEntity.setPosition(this.posX, this.posY + this.getMountedYOffset() + this.riddenByEntity.getYOffset(), this.posZ);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the Y Offset of this entity.\r\n     */\r\n    public double getYOffset() {\r\n        return 0.0D;\r\n    }\r\n\r\n    /**\r\n     * Returns the Y offset from the entity's position for any entity riding this one.\r\n     */\r\n    public double getMountedYOffset() {\r\n        return (double) this.height * 0.75D;\r\n    }\r\n\r\n    /**\r\n     * Called when a player mounts an entity. e.g. mounts a pig, mounts a boat.\r\n     */\r\n    public void mountEntity(final Entity entityIn) {\r\n        this.entityRiderPitchDelta = 0.0D;\r\n        this.entityRiderYawDelta = 0.0D;\r\n\r\n        if (entityIn == null) {\r\n            if (this.ridingEntity != null) {\r\n                this.setLocationAndAngles(this.ridingEntity.posX, this.ridingEntity.getEntityBoundingBox().minY + (double) this.ridingEntity.height, this.ridingEntity.posZ, this.rotationYaw, this.rotationPitch);\r\n                this.ridingEntity.riddenByEntity = null;\r\n            }\r\n\r\n            this.ridingEntity = null;\r\n        } else {\r\n            if (this.ridingEntity != null) {\r\n                this.ridingEntity.riddenByEntity = null;\r\n            }\r\n\r\n            if (entityIn != null) {\r\n                for (Entity entity = entityIn.ridingEntity; entity != null; entity = entity.ridingEntity) {\r\n                    if (entity == this) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.ridingEntity = entityIn;\r\n            entityIn.riddenByEntity = this;\r\n        }\r\n    }\r\n\r\n    public void setPositionAndRotation2(final double x, double y, final double z, final float yaw, final float pitch, final int posRotationIncrements, final boolean p_180426_10_) {\r\n        this.setPosition(x, y, z);\r\n        this.setRotation(yaw, pitch);\r\n        final List<AxisAlignedBB> list = this.worldObj.getCollidingBoundingBoxes(this, this.getEntityBoundingBox().contract(0.03125D, 0.0D, 0.03125D));\r\n\r\n        if (!list.isEmpty()) {\r\n            double d0 = 0.0D;\r\n\r\n            for (final AxisAlignedBB axisalignedbb : list) {\r\n                if (axisalignedbb.maxY > d0) {\r\n                    d0 = axisalignedbb.maxY;\r\n                }\r\n            }\r\n\r\n            y = y + (d0 - this.getEntityBoundingBox().minY);\r\n            this.setPosition(x, y, z);\r\n        }\r\n    }\r\n\r\n    public float getCollisionBorderSize() {\r\n        return 0.1F;\r\n    }\r\n\r\n    /**\r\n     * returns a (normalized) vector of where this entity is looking\r\n     */\r\n    public Vec3 getLookVec() {\r\n        return null;\r\n    }\r\n\r\n    public void func_181015_d(final BlockPos p_181015_1_) {\r\n        if (this.timeUntilPortal > 0) {\r\n            this.timeUntilPortal = this.getPortalCooldown();\r\n        } else {\r\n            if (!this.worldObj.isRemote && !p_181015_1_.equals(this.field_181016_an)) {\r\n                this.field_181016_an = p_181015_1_;\r\n                final BlockPattern.PatternHelper blockpattern$patternhelper = Blocks.portal.func_181089_f(this.worldObj, p_181015_1_);\r\n                final double d0 = blockpattern$patternhelper.getFinger().getAxis() == EnumFacing.Axis.X ? (double) blockpattern$patternhelper.func_181117_a().getZ() : (double) blockpattern$patternhelper.func_181117_a().getX();\r\n                double d1 = blockpattern$patternhelper.getFinger().getAxis() == EnumFacing.Axis.X ? this.posZ : this.posX;\r\n                d1 = Math.abs(MathHelper.func_181160_c(d1 - (double) (blockpattern$patternhelper.getFinger().rotateY().getAxisDirection() == EnumFacing.AxisDirection.NEGATIVE ? 1 : 0), d0, d0 - (double) blockpattern$patternhelper.func_181118_d()));\r\n                final double d2 = MathHelper.func_181160_c(this.posY - 1.0D, blockpattern$patternhelper.func_181117_a().getY(), blockpattern$patternhelper.func_181117_a().getY() - blockpattern$patternhelper.func_181119_e());\r\n                this.field_181017_ao = new Vec3(d1, d2, 0.0D);\r\n                this.field_181018_ap = blockpattern$patternhelper.getFinger();\r\n            }\r\n\r\n            this.inPortal = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the amount of cooldown before this entity can use a portal again.\r\n     */\r\n    public int getPortalCooldown() {\r\n        return 300;\r\n    }\r\n\r\n    /**\r\n     * Sets the velocity to the args. Args: x, y, z\r\n     */\r\n    public void setVelocity(final double x, final double y, final double z) {\r\n        this.motionX = x;\r\n        this.motionY = y;\r\n        this.motionZ = z;\r\n    }\r\n\r\n    public void handleHealthUpdate(final byte id) {\r\n    }\r\n\r\n    /**\r\n     * Setups the entity to do the hurt animation. Only used by packets in multiplayer.\r\n     */\r\n    public void performHurtAnimation() {\r\n    }\r\n\r\n    /**\r\n     * returns the inventory of this entity (only used in EntityPlayerMP it seems)\r\n     */\r\n    public ItemStack[] getInventory() {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the held item, or an armor slot. Slot 0 is held item. Slot 1-4 is armor. Params: Item, slot\r\n     */\r\n    public void setCurrentItemOrArmor(final int slotIn, final ItemStack stack) {\r\n    }\r\n\r\n    /**\r\n     * Returns true if the entity is on fire. Used by render to add the fire effect on rendering.\r\n     */\r\n    public boolean isBurning() {\r\n        final boolean flag = this.worldObj != null && this.worldObj.isRemote;\r\n        return !this.isImmuneToFire && (this.fire > 0 || flag && this.getFlag(0));\r\n    }\r\n\r\n    /**\r\n     * Returns true if the entity is riding another entity, used by render to rotate the legs to be in 'sit' position\r\n     * for players.\r\n     */\r\n    public boolean isRiding() {\r\n        return this.ridingEntity != null;\r\n    }\r\n\r\n    /**\r\n     * Returns if this entity is sneaking.\r\n     */\r\n    public boolean isSneaking() {\r\n        return this.getFlag(1);\r\n    }\r\n\r\n    /**\r\n     * Sets the sneaking flag.\r\n     */\r\n    public void setSneaking(final boolean sneaking) {\r\n        this.setFlag(1, sneaking);\r\n    }\r\n\r\n    /**\r\n     * Get if the Entity is sprinting.\r\n     */\r\n    public boolean isSprinting() {\r\n        return this.getFlag(3);\r\n    }\r\n\r\n    /**\r\n     * Set sprinting switch for Entity.\r\n     */\r\n    public void setSprinting(final boolean sprinting) {\r\n        this.setFlag(3, sprinting);\r\n    }\r\n\r\n    public boolean isInvisible() {\r\n        return this.getFlag(5);\r\n    }\r\n\r\n    /**\r\n     * Only used by renderer in EntityLivingBase subclasses.\r\n     * Determines if an entity is visible or not to a specfic player, if the entity is normally invisible.\r\n     * For EntityLivingBase subclasses, returning false when invisible will render the entity semitransparent.\r\n     */\r\n    public boolean isInvisibleToPlayer(final EntityPlayer player) {\r\n        return !player.isSpectator() && this.isInvisible();\r\n    }\r\n\r\n    public void setInvisible(final boolean invisible) {\r\n        this.setFlag(5, invisible);\r\n    }\r\n\r\n    public boolean isEating() {\r\n        return this.getFlag(4);\r\n    }\r\n\r\n    public void setEating(final boolean eating) {\r\n        this.setFlag(4, eating);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the flag is active for the entity. Known flags: 0) is burning; 1) is sneaking; 2) is riding\r\n     * something; 3) is sprinting; 4) is eating\r\n     */\r\n    protected boolean getFlag(final int flag) {\r\n        return (this.dataWatcher.getWatchableObjectByte(0) & 1 << flag) != 0;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable a entity flag, see getEntityFlag to read the know flags.\r\n     */\r\n    protected void setFlag(final int flag, final boolean set) {\r\n        final byte b0 = this.dataWatcher.getWatchableObjectByte(0);\r\n\r\n        if (set) {\r\n            this.dataWatcher.updateObject(0, Byte.valueOf((byte) (b0 | 1 << flag)));\r\n        } else {\r\n            this.dataWatcher.updateObject(0, Byte.valueOf((byte) (b0 & ~(1 << flag))));\r\n        }\r\n    }\r\n\r\n    public int getAir() {\r\n        return this.dataWatcher.getWatchableObjectShort(1);\r\n    }\r\n\r\n    public void setAir(final int air) {\r\n        this.dataWatcher.updateObject(1, Short.valueOf((short) air));\r\n    }\r\n\r\n    /**\r\n     * Called when a lightning bolt hits the entity.\r\n     */\r\n    public void onStruckByLightning(final EntityLightningBolt lightningBolt) {\r\n        this.attackEntityFrom(DamageSource.lightningBolt, 5.0F);\r\n        ++this.fire;\r\n\r\n        if (this.fire == 0) {\r\n            this.setFire(8);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method gets called when the entity kills another one.\r\n     */\r\n    public void onKillEntity(final EntityLivingBase entityLivingIn) {\r\n    }\r\n\r\n    protected boolean pushOutOfBlocks(final double x, final double y, final double z) {\r\n        final BlockPos blockpos = new BlockPos(x, y, z);\r\n        final double d0 = x - (double) blockpos.getX();\r\n        final double d1 = y - (double) blockpos.getY();\r\n        final double d2 = z - (double) blockpos.getZ();\r\n        final List<AxisAlignedBB> list = this.worldObj.func_147461_a(this.getEntityBoundingBox());\r\n\r\n        if (list.isEmpty() && !this.worldObj.isBlockFullCube(blockpos)) {\r\n            return false;\r\n        } else {\r\n            int i = 3;\r\n            double d3 = 9999.0D;\r\n\r\n            if (!this.worldObj.isBlockFullCube(blockpos.west()) && d0 < d3) {\r\n                d3 = d0;\r\n                i = 0;\r\n            }\r\n\r\n            if (!this.worldObj.isBlockFullCube(blockpos.east()) && 1.0D - d0 < d3) {\r\n                d3 = 1.0D - d0;\r\n                i = 1;\r\n            }\r\n\r\n            if (!this.worldObj.isBlockFullCube(blockpos.up()) && 1.0D - d1 < d3) {\r\n                d3 = 1.0D - d1;\r\n                i = 3;\r\n            }\r\n\r\n            if (!this.worldObj.isBlockFullCube(blockpos.north()) && d2 < d3) {\r\n                d3 = d2;\r\n                i = 4;\r\n            }\r\n\r\n            if (!this.worldObj.isBlockFullCube(blockpos.south()) && 1.0D - d2 < d3) {\r\n                d3 = 1.0D - d2;\r\n                i = 5;\r\n            }\r\n\r\n            final float f = this.rand.nextFloat() * 0.2F + 0.1F;\r\n\r\n            if (i == 0) {\r\n                this.motionX = -f;\r\n            }\r\n\r\n            if (i == 1) {\r\n                this.motionX = f;\r\n            }\r\n\r\n            if (i == 3) {\r\n                this.motionY = f;\r\n            }\r\n\r\n            if (i == 4) {\r\n                this.motionZ = -f;\r\n            }\r\n\r\n            if (i == 5) {\r\n                this.motionZ = f;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the Entity inside a web block.\r\n     */\r\n    public void setInWeb() {\r\n        this.isInWeb = true;\r\n        this.fallDistance = 0.0F;\r\n    }\r\n\r\n    /**\r\n     * Gets the name of this command sender (usually username, but possibly \"Rcon\")\r\n     */\r\n    public String getCommandSenderName() {\r\n        if (this.hasCustomName()) {\r\n            return this.getCustomNameTag();\r\n        } else {\r\n            String s = EntityList.getEntityString(this);\r\n\r\n            if (s == null) {\r\n                s = \"generic\";\r\n            }\r\n\r\n            return StatCollector.translateToLocal(\"entity.\" + s + \".name\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the Entity parts making up this Entity (currently only for dragons)\r\n     */\r\n    public Entity[] getParts() {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns true if Entity argument is equal to this Entity\r\n     */\r\n    public boolean isEntityEqual(final Entity entityIn) {\r\n        return this == entityIn;\r\n    }\r\n\r\n    public float getRotationYawHead() {\r\n        return 0.0F;\r\n    }\r\n\r\n    /**\r\n     * Sets the head's yaw rotation of the entity.\r\n     */\r\n    public void setRotationYawHead(final float rotation) {\r\n    }\r\n\r\n    public void func_181013_g(final float p_181013_1_) {\r\n    }\r\n\r\n    /**\r\n     * If returns false, the item will not inflict any damage against entities.\r\n     */\r\n    public boolean canAttackWithItem() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Called when a player attacks an entity. If this returns true the attack will not happen.\r\n     */\r\n    public boolean hitByEntity(final Entity entityIn) {\r\n        return false;\r\n    }\r\n\r\n    public String toString() {\r\n        return String.format(\"%s['%s'/%d, l='%s', x=%.2f, y=%.2f, z=%.2f]\", this.getClass().getSimpleName(), this.getCommandSenderName(), Integer.valueOf(this.entityId), this.worldObj == null ? \"~NULL~\" : this.worldObj.getWorldInfo().getWorldName(), Double.valueOf(this.posX), Double.valueOf(this.posY), Double.valueOf(this.posZ));\r\n    }\r\n\r\n    public boolean isEntityInvulnerable(final DamageSource source) {\r\n        return this.invulnerable && source != DamageSource.outOfWorld && !source.isCreativePlayer();\r\n    }\r\n\r\n    /**\r\n     * Sets this entity's location and angles to the location and angles of the passed in entity.\r\n     */\r\n    public void copyLocationAndAnglesFrom(final Entity entityIn) {\r\n        this.setLocationAndAngles(entityIn.posX, entityIn.posY, entityIn.posZ, entityIn.rotationYaw, entityIn.rotationPitch);\r\n    }\r\n\r\n    /**\r\n     * Prepares this entity in new dimension by copying NBT data from entity in old dimension\r\n     */\r\n    public void copyDataFromOld(final Entity entityIn) {\r\n        final NBTTagCompound nbttagcompound = new NBTTagCompound();\r\n        entityIn.writeToNBT(nbttagcompound);\r\n        this.readFromNBT(nbttagcompound);\r\n        this.timeUntilPortal = entityIn.timeUntilPortal;\r\n        this.field_181016_an = entityIn.field_181016_an;\r\n        this.field_181017_ao = entityIn.field_181017_ao;\r\n        this.field_181018_ap = entityIn.field_181018_ap;\r\n    }\r\n\r\n    /**\r\n     * Teleports the entity to another dimension. Params: Dimension number to teleport to\r\n     */\r\n    public void travelToDimension(final int dimensionId) {\r\n        if (!this.worldObj.isRemote && !this.isDead) {\r\n            this.worldObj.theProfiler.startSection(\"changeDimension\");\r\n            final MinecraftServer minecraftserver = MinecraftServer.getServer();\r\n            final int i = this.dimension;\r\n            final WorldServer worldserver = minecraftserver.worldServerForDimension(i);\r\n            WorldServer worldserver1 = minecraftserver.worldServerForDimension(dimensionId);\r\n            this.dimension = dimensionId;\r\n\r\n            if (i == 1 && dimensionId == 1) {\r\n                worldserver1 = minecraftserver.worldServerForDimension(0);\r\n                this.dimension = 0;\r\n            }\r\n\r\n            this.worldObj.removeEntity(this);\r\n            this.isDead = false;\r\n            this.worldObj.theProfiler.startSection(\"reposition\");\r\n            minecraftserver.getConfigurationManager().transferEntityToWorld(this, i, worldserver, worldserver1);\r\n            this.worldObj.theProfiler.endStartSection(\"reloading\");\r\n            final Entity entity = EntityList.createEntityByName(EntityList.getEntityString(this), worldserver1);\r\n\r\n            if (entity != null) {\r\n                entity.copyDataFromOld(this);\r\n\r\n                if (i == 1 && dimensionId == 1) {\r\n                    final BlockPos blockpos = this.worldObj.getTopSolidOrLiquidBlock(worldserver1.getSpawnPoint());\r\n                    entity.moveToBlockPosAndAngles(blockpos, entity.rotationYaw, entity.rotationPitch);\r\n                }\r\n\r\n                worldserver1.spawnEntityInWorld(entity);\r\n            }\r\n\r\n            this.isDead = true;\r\n            this.worldObj.theProfiler.endSection();\r\n            worldserver.resetUpdateEntityTick();\r\n            worldserver1.resetUpdateEntityTick();\r\n            this.worldObj.theProfiler.endSection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Explosion resistance of a block relative to this entity\r\n     */\r\n    public float getExplosionResistance(final Explosion explosionIn, final World worldIn, final BlockPos pos, final IBlockState blockStateIn) {\r\n        return blockStateIn.getBlock().getExplosionResistance(this);\r\n    }\r\n\r\n    public boolean verifyExplosion(final Explosion explosionIn, final World worldIn, final BlockPos pos, final IBlockState blockStateIn, final float p_174816_5_) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * The maximum height from where the entity is alowed to jump (used in pathfinder)\r\n     */\r\n    public int getMaxFallHeight() {\r\n        return 3;\r\n    }\r\n\r\n    public Vec3 func_181014_aG() {\r\n        return this.field_181017_ao;\r\n    }\r\n\r\n    public EnumFacing func_181012_aH() {\r\n        return this.field_181018_ap;\r\n    }\r\n\r\n    /**\r\n     * Return whether this entity should NOT trigger a pressure plate or a tripwire.\r\n     */\r\n    public boolean doesEntityNotTriggerPressurePlate() {\r\n        return false;\r\n    }\r\n\r\n    public void addEntityCrashInfo(final CrashReportCategory category) {\r\n        category.addCrashSectionCallable(\"Entity Type\", () -> EntityList.getEntityString(Entity.this) + \" (\" + Entity.this.getClass().getCanonicalName() + \")\");\r\n        category.addCrashSection(\"Entity ID\", Integer.valueOf(this.entityId));\r\n        category.addCrashSectionCallable(\"Entity Name\", () -> Entity.this.getCommandSenderName());\r\n        category.addCrashSection(\"Entity's Exact location\", String.format(\"%.2f, %.2f, %.2f\", Double.valueOf(this.posX), Double.valueOf(this.posY), Double.valueOf(this.posZ)));\r\n        category.addCrashSection(\"Entity's Block location\", CrashReportCategory.getCoordinateInfo(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY), MathHelper.floor_double(this.posZ)));\r\n        category.addCrashSection(\"Entity's Momentum\", String.format(\"%.2f, %.2f, %.2f\", Double.valueOf(this.motionX), Double.valueOf(this.motionY), Double.valueOf(this.motionZ)));\r\n        category.addCrashSectionCallable(\"Entity's Rider\", () -> Entity.this.riddenByEntity.toString());\r\n        category.addCrashSectionCallable(\"Entity's Vehicle\", () -> Entity.this.ridingEntity.toString());\r\n    }\r\n\r\n    /**\r\n     * Return whether this entity should be rendered as on fire.\r\n     */\r\n    public boolean canRenderOnFire() {\r\n        return this.isBurning();\r\n    }\r\n\r\n    public UUID getUniqueID() {\r\n        return this.entityUniqueID;\r\n    }\r\n\r\n    public boolean isPushedByWater() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the formatted ChatComponent that will be used for the sender's username in chat\r\n     */\r\n    public IChatComponent getDisplayName() {\r\n        final ChatComponentText chatcomponenttext = new ChatComponentText(this.getCommandSenderName());\r\n        chatcomponenttext.getChatStyle().setChatHoverEvent(this.getHoverEvent());\r\n        chatcomponenttext.getChatStyle().setInsertion(this.getUniqueID().toString());\r\n        return chatcomponenttext;\r\n    }\r\n\r\n    /**\r\n     * Sets the custom name tag for this entity\r\n     */\r\n    public void setCustomNameTag(final String name) {\r\n        this.dataWatcher.updateObject(2, name);\r\n    }\r\n\r\n    public String getCustomNameTag() {\r\n        return this.dataWatcher.getWatchableObjectString(2);\r\n    }\r\n\r\n    /**\r\n     * Returns true if this thing is named\r\n     */\r\n    public boolean hasCustomName() {\r\n        return this.dataWatcher.getWatchableObjectString(2).length() > 0;\r\n    }\r\n\r\n    public void setAlwaysRenderNameTag(final boolean alwaysRenderNameTag) {\r\n        this.dataWatcher.updateObject(3, Byte.valueOf((byte) (alwaysRenderNameTag ? 1 : 0)));\r\n    }\r\n\r\n    public boolean getAlwaysRenderNameTag() {\r\n        return this.dataWatcher.getWatchableObjectByte(3) == 1;\r\n    }\r\n\r\n    /**\r\n     * Sets the position of the entity and updates the 'last' variables\r\n     */\r\n    public void setPositionAndUpdate(final double x, final double y, final double z) {\r\n        this.setLocationAndAngles(x, y, z, this.rotationYaw, this.rotationPitch);\r\n    }\r\n\r\n    public boolean getAlwaysRenderNameTagForRender() {\r\n        return this.getAlwaysRenderNameTag();\r\n    }\r\n\r\n    public void onDataWatcherUpdate(final int dataID) {\r\n    }\r\n\r\n    public EnumFacing getHorizontalFacing() {\r\n        return EnumFacing.getHorizontal(MathHelper.floor_double((double) (this.rotationYaw * 4.0F / 360.0F) + 0.5D) & 3);\r\n    }\r\n\r\n    protected HoverEvent getHoverEvent() {\r\n        final NBTTagCompound nbttagcompound = new NBTTagCompound();\r\n        final String s = EntityList.getEntityString(this);\r\n        nbttagcompound.setString(\"id\", this.getUniqueID().toString());\r\n\r\n        if (s != null) {\r\n            nbttagcompound.setString(\"type\", s);\r\n        }\r\n\r\n        nbttagcompound.setString(\"name\", this.getCommandSenderName());\r\n        return new HoverEvent(HoverEvent.Action.SHOW_ENTITY, new ChatComponentText(nbttagcompound.toString()));\r\n    }\r\n\r\n    public boolean isSpectatedByPlayer(final EntityPlayerMP player) {\r\n        return true;\r\n    }\r\n\r\n    public AxisAlignedBB getEntityBoundingBox() {\r\n        return this.boundingBox.expand(0, 0, 0);\r\n    }\r\n\r\n    public void setEntityBoundingBox(final AxisAlignedBB bb) {\r\n        this.boundingBox = bb;\r\n    }\r\n\r\n    public float getEyeHeight() {\r\n        return this.height * 0.85F;\r\n    }\r\n\r\n    public boolean isOutsideBorder() {\r\n        return this.isOutsideBorder;\r\n    }\r\n\r\n    public void setOutsideBorder(final boolean outsideBorder) {\r\n        this.isOutsideBorder = outsideBorder;\r\n    }\r\n\r\n    public boolean replaceItemInInventory(final int inventorySlot, final ItemStack itemStackIn) {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Send a chat message to the CommandSender\r\n     *\r\n     * @param component The ChatComponent to send\r\n     */\r\n    public void addChatMessage(final IChatComponent component) {\r\n    }\r\n\r\n    /**\r\n     * Returns {@code true} if the CommandSender is allowed to execute the command, {@code false} if not\r\n     *\r\n     * @param permLevel   The permission level required to execute the command\r\n     * @param commandName The name of the command\r\n     */\r\n    public boolean canCommandSenderUseCommand(final int permLevel, final String commandName) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the position in the world. <b>{@code null} is not allowed!</b> If you are not an entity in the world, return\r\n     * the coordinates 0, 0, 0\r\n     */\r\n    public BlockPos getPosition() {\r\n        return new BlockPos(this.posX, this.posY + 0.5D, this.posZ);\r\n    }\r\n\r\n    /**\r\n     * Get the position vector. <b>{@code null} is not allowed!</b> If you are not an entity in the world, return 0.0D,\r\n     * 0.0D, 0.0D\r\n     */\r\n    public Vec3 getPositionVector() {\r\n        return new Vec3(this.posX, this.posY, this.posZ);\r\n    }\r\n\r\n    /**\r\n     * Get the world, if available. <b>{@code null} is not allowed!</b> If you are not an entity in the world, return\r\n     * the overworld\r\n     */\r\n    public World getEntityWorld() {\r\n        return this.worldObj;\r\n    }\r\n\r\n    /**\r\n     * Returns the entity associated with the command sender. MAY BE NULL!\r\n     */\r\n    public Entity getCommandSenderEntity() {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the command sender should be sent feedback about executed impl\r\n     */\r\n    public boolean sendCommandFeedback() {\r\n        return false;\r\n    }\r\n\r\n    public void setCommandStat(final CommandResultStats.Type type, final int amount) {\r\n        this.cmdResultStats.func_179672_a(this, type, amount);\r\n    }\r\n\r\n    public CommandResultStats getCommandStats() {\r\n        return this.cmdResultStats;\r\n    }\r\n\r\n    public void func_174817_o(final Entity entityIn) {\r\n        this.cmdResultStats.func_179671_a(entityIn.getCommandStats());\r\n    }\r\n\r\n    public NBTTagCompound getNBTTagCompound() {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Called when client receives entity's NBTTagCompound from server.\r\n     */\r\n    public void clientUpdateEntityNBT(final NBTTagCompound compound) {\r\n    }\r\n\r\n    /**\r\n     * New version of interactWith that includes vector information on where precisely the player targeted.\r\n     */\r\n    public boolean interactAt(final EntityPlayer player, final Vec3 targetVec3) {\r\n        return false;\r\n    }\r\n\r\n    public boolean isImmuneToExplosions() {\r\n        return false;\r\n    }\r\n\r\n    protected void applyEnchantments(final EntityLivingBase entityLivingBaseIn, final Entity entityIn) {\r\n        if (entityIn instanceof EntityLivingBase) {\r\n            EnchantmentHelper.applyThornEnchantments((EntityLivingBase) entityIn, entityLivingBaseIn);\r\n        }\r\n\r\n        EnchantmentHelper.applyArthropodEnchantments(entityLivingBaseIn, entityIn);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/net/minecraft/entity/Entity.java b/net/minecraft/entity/Entity.java
--- a/net/minecraft/entity/Entity.java	(revision 12f741f73fd2ba762ae96403a891020f2d06a691)
+++ b/net/minecraft/entity/Entity.java	(date 1727823012393)
@@ -135,7 +135,7 @@
      */
     public boolean isCollided;
     public boolean velocityChanged;
-    protected boolean isInWeb;
+    public boolean isInWeb;
     private boolean isOutsideBorder;
 
     /**
